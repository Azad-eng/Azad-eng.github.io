[{"categories":null,"content":"书签 📝 ？\r。\r","date":"2023-02-27","objectID":"/Christophe/:0:1","tags":null,"title":"","uri":"/Christophe/"},{"categories":null,"content":"书签 📝 哪一个才是真正的科学实验？\r一个人操作着价值五万美金的福兰克斯坦仪器进行科学实验，如果他事先就知道了结果，那么整件事就毫无科学可言。然而修理摩托车的人如果为了检查电池是否仍然有电 而按喇叭，却是一种真正的实验，因为他是用实际行动去证实他的假设。\r休谟的经验主义论\r休谟认为，一个人如果能遵循经验中最严格的归纳和演绎的思维，就能够认识世界的本质。他的这种看法被归纳为经验主义，也就是相信所有的认知来自于人的感官。 经验主义的第一个问题和本体的性质有关。如果我们所有的知识都来自于感官，那么给与这些感官知识的本体是什么？ 经验主义的第二个问题是，如果一个人假设我们所有的认知都来自于感官，那么哪一个感官接收了因果关系的认知？(P177)\r对事物抱有强信心会导致狂热态度的产生吗？\r如果你对事情有完全的信心，就不太可能产生狂热的态度。就拿太阳来说吧，没有人会为了它明天会升起而兴奋不已，因为这是必然的现象。\r","date":"2023-02-26","objectID":"/ZenMotor/:0:1","tags":null,"title":"","uri":"/ZenMotor/"},{"categories":null,"content":"\r","date":"2023-02-26","objectID":"/reading/:0:0","tags":null,"title":"阅读记录之旅","uri":"/reading/"},{"categories":null,"content":"形而上学类~ 禅与摩托车维修艺术\r\"❤❤❤Zen and the Art of Motorcycle Maintenance\"\r","date":"2023-02-26","objectID":"/reading/:0:1","tags":null,"title":"阅读记录之旅","uri":"/reading/"},{"categories":null,"content":"理想主义之书~ 约翰·克利斯朵夫\r\"❤❤❤Jean-Christophe\"\r","date":"2023-02-26","objectID":"/reading/:0:2","tags":null,"title":"阅读记录之旅","uri":"/reading/"},{"categories":null,"content":"其他~ ","date":"2023-02-26","objectID":"/reading/:0:3","tags":null,"title":"阅读记录之旅","uri":"/reading/"},{"categories":["工具"],"content":"Regex正则表达式 组成 （1）字符类 1.字符集：[ABC] 匹配集合中的任何一个字符 例子：[aeiou] 匹配：glib jocks vex dwarves! 2.否定集[^ABC] 匹配不在集合中的任何一个字符 例子：[^aeiou] 匹配：glib jocks vex dwarves! 3.范围[A-Z] 匹配（含）两个指定字符之间的任意字符 例子：[g-s] 匹配：abcdefghijklmnopqrstuvwxyz 4.点. 匹配除换行符之外的任何一个字符 相当于[^\\n\\r] 例子：.匹配：glib jocks vex dwarves! 5.匹配任何[\\s\\S] 一个字符集，可用于匹配任何一个字符，包括换行符 例子：[\\s\\S]匹配：glib jocks vex dwarves! 6.单词\\w 匹配任何一个单词字符（字母数字和下划线） 仅匹配低位 ASCII 字符（无重音字符或非罗马字符），相当于[A-Za-z0-9_] 例子：\\w匹配：bonjour,mon frère 7.非单词\\W 匹配任何一个非单词字符（字母数字和下划线） 相当于[^A-Za-z0-9_] 例子：\\W匹配：bonjour,monNULLfrère 8.数字\\d 匹配任何一个数字字符 (0-9) 相当于[0-9] 例子：\\d匹配：+1-(444)-555-1234 9.非数字\\D 匹配任何一个非数字字符 (0-9) 相当于[^0-9] 例子：\\D匹配：+1-(444)-555-1234 10.空格\\s 匹配任何一个空白字符（空格、制表符、换行符） 相当于[^0-9] 例子：\\s匹配：glibNULLjocksNULLvexNULLdwarves! 11.非空格\\S 匹配任何一个非空白字符（空格、制表符、换行符） 相当于[^0-9] 例子：\\S匹配：glib jocks vex dwarves! （2）量词和交替 1.加号：+匹配 1 个或多个前面的标记 例子：b\\w+ 匹配：b be bee beer beers 2.星号：*匹配 0 个或多个前面的标记 例子：b\\w* 匹配：b be bee beer beers 3.量词：{1,3}匹配指定数量的的标记 {1,3}将匹配 1 到 3，{3}将完全匹配 3，{3,}将匹配 3 个或更多 例子：b\\w{2,3}* 匹配：b be bee beer beers 4.optional：？匹配前面标记的 0 或 1 个，有效地使其成为可选的 例子：colou?r* 匹配：color colour 5.lazy：？使前面的量词惰性化，使其匹配尽可能少的字符 默认情况下，量词是贪婪的，会匹配尽可能多的字符 例子：b\\w+?* 匹配：b be bee beer beers 6.交替：|类似于布尔 OR。匹配之前或之后的表达式 它可以在一个组内运行，也可以在整个表达式上运行 例子：b(a|e|i)d 匹配：bad bud bod bed bid （3）锚点 1.开始：^匹配字符串的开头 如果m启用了多行标志 ( )，则匹配一行的开头。这匹配一个位置，而不是一个字符 例子：^\\w+ 匹配：she sells seashells 2.结尾：$匹配字符串的结尾 如果m启用了多行标志 ( )，则匹配一行的结尾。这匹配一个位置，而不是一个字符 例子：\\w+$ 匹配：she sells seashells 3.单词边界：\\b匹配单词字符和非单词字符或位置（字符串的开始/结束）之间的单词边界位置 例子：s\\b 匹配：she sells seashells 4.非单词边界：\\B匹配任何不是单词边界的位置 这匹配一个位置，而不是一个字符。 例子：s\\B 匹配：she sells seashells 参考 ","date":"2023-02-26","objectID":"/regex/:0:1","tags":["Regex"],"title":"正则表达式初识","uri":"/regex/"},{"categories":null,"content":"通用命令摘要 1. 文件夹操作 lists 当前目录下的所有文件 $ ls change directory 进入指定目录 cd \u003cpath to directory\u003e /* 切换到主目录 */ cd ~ /* 切换到父目录 */ cd .. -make a new directory 用给定的名称创建一个新目录 mkdir \u003cdirectory name\u003e move the file 将给定源的文件移动到给定的目标 mv \u003csource path\u003e \u003cdestination path\u003e ","date":"2023-02-07","objectID":"/memo/2023/:0:1","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"Windows PowerShell 命令摘要 1. 文件夹操作 解压指定目录下的文件 Expand-Archive -\u003cDestinationPath\u003e . -Force \u003czipFile\u003e 常用操作 在任意文件目录下：shift + 右键单击“在此处打开PowerShell窗口”将会自动切换到该文件目录 ","date":"2023-02-07","objectID":"/memo/2023/:0:2","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"Git Bash 命令摘要 1. 文件夹操作 解压指定目录下的文件 unzip \u003czipFile\u003e 常用操作 ctrl + c 退出命令行模式 ","date":"2023-02-07","objectID":"/memo/2023/:0:3","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"IDEA相关 1. 创建Javafx-Maven项目 step1- 创建Javfx项目 File-New-Project-Java FX-Next-Finish step2- 添加Maven框架 右键点击项目-Add Framework Support-Maven-Ok step3- 在 Project Structrue-Modules-Sources 按下图设置项目文件目录 step4- 将自动生成的fxml文件移动到resources/fxml/下，注意导入Maven以后必须用一个前导斜杠调用它，比如： FXMLLoader.load(getClass().getResource(\"/fxml/sample.fxml\")) 2. 显示version control 取消勾选File-Settings-Version Control-Commit-[Use non-modal commit interface] ","date":"2023-02-07","objectID":"/memo/2023/:0:4","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"Github相关 配置ssh免密登录 step1 生成密钥对 $ ssh-keygen -t rsa -C \"test@email.com\" step2 检查电脑系统用户目录下是否出现.ssh文件夹（ls: id_rsa,id_rsa.pub step3 登录 github 打开个人中心 点击 Settings-SSH and GPG keys-New SSHkey，填写标题（比如：设备名+ssh -\u003e sv7-ssh)， 将id_rsa.pub文件的全部内容粘贴进去 ","date":"2023-02-07","objectID":"/memo/2023/:0:5","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"BLOG相关 1. 打开本地博客 $ hugo server -e production --disableFastRender --port=1515 -D 2. 更新博客网站内容流程 step1- 关闭本地博客 step2- 博客项目下打开bash $ hugo $ cd public $ git status $ git add . $ git commit -a -m \"xxxx\" $ git push -u origin master --force step3- 确认github项目是否更新 step4- 确认项目-Settings-Pages-site是否更新 step5- 点击Visit site 3. LoveIt主题admonition样式代码 4. 注意事项 项目bin目录地址更改以后，环境变量里的hugo/bin地址也要相应改动 5.文章属性配置 title: “标题” subTitle: “副标题” description: “主页显示描述，与\u003c!- -more- -\u003e 搭配使用，如果没有该属性，主页显示正文开头” hiddenFromHomePage: true #文章是否出现在主页 url: /ZenMotor/ #文章链接地址 tags: [ “标签0”, “标签1”, “…” ] categories: “分类0” “分类1” … date: 2022-02-22 #创建日期 lastmod: 2022-2-22 #更新日期 comment: false #是否打开评论 draft: true #是否为草稿，是则部署时会不显示文章 ","date":"2023-02-07","objectID":"/memo/2023/:0:6","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"JAVA 经验总结 总结\r1.程序异常时——\u003e检查程序本身逻辑 ——»是否由未被捕获的异常（比如空指针）导致——»\u003e在可能出现异常的地方用try-catch包出再调试 ——»是否由未被识别的命名冲突导致 Runtime类 —— 程序调用外部exe 摘要\rJava 中，Runtime 类用于与每个 Java 应用程序交互，每个 Java 应用程序都有一个 Runtime 类的单个实例，允许应用程序与应用程序运行的环境进行交互\r/** * 调用外部exe程序并通过process.getInputStream()捕获外部程序的输出流，然后System.out * to learn: 对于应用程序来说，其输出流有两种： 标准输出流 标准错误流 因此，一个健壮的代码应同时对这两种输出流进行处理 */ class RuntimeTest{ public static void main(String[] args) throws IOException { final Process process = Runtime.getRuntime().exec(\"E:\\\\xx\\\\xx.exe\"); //get input stream handleProcessStreamByLine(process.getInputStream()); handleProcessStreamByBytes(process, process.getInputStream()); //get error stream handleProcessStreamByLine(process.getErrorStream()); handleProcessStreamByBytes(process, process.getErrorStream()); //to learn: 验证外部程序是否执行成功 // Process.exitValue()/Process.waitFor() 获取外部程序的返回值为 0 表示执行成功，其余值表示外部程序执行出错 try { int exitValue = process.waitFor(); System.out.println(\"process exitValue:\" + exitValue); } catch (Exception e) { e.printStackTrace(); } } private void handleProcessStreamByLine(InputStream streamToHandle) { new Thread(() -\u003e { BufferedReader br = new BufferedReader(new InputStreamReader(streamToHandle)); String line; try { while ((line = br.readLine()) != null) { System.out.println(line); } br.close(); } catch (IOException e) { e.printStackTrace(); } }).start(); } private void handleProcessStreamByBytes(Process process, InputStream streamToHandle){ new Thread(() -\u003e { try { while (process.isAlive()) { int length = streamToHandle.available(); if (length \u003e 0) { byte[] bytes = new byte[streamToHandle.available()]; streamToHandle.read(bytes); System.out.println(new String(bytes)); } } streamToHandle.close(); } catch (IOException e) { e.printStackTrace(); } }).start(); } } ","date":"2023-02-07","objectID":"/memo/2023/:0:7","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"JAVAFX TabPane \u003cTabPane prefHeight=\"100.0\" prefWidth=\"200.0\"\u003e \u003cTab fx:id=\"tab1\" closable=\"false\" text=\"tab1\"\u003e \u003cfx:include source=\"options/tab1.fxml\"/\u003e \u003c/Tab\u003e \u003cTab fx:id=\"tab2\" onClosed=\"#closeTabEvent\" text=\"tab2\"\u003e \u003cfx:include source=\"options/tab2.fxml\"/\u003e \u003c/Tab\u003e \u003c/TabPane\u003e 细节注意\r1.closable=false表示此tab不可以关闭 2.onClosed事件在关闭tab后触发 3.source的路径的根目录是fxml。比如resources/fxml/options/.. ###树莓派 在Raspberry Pi上打开一个终端窗口，可以通过单击桌面上的“终端”图标或Ctrl+Alt+T。 ###Linux命令 #浏览已安装的程序 dpkg --list #查看文件权限和所有者等详细信息 ls -l filename ","date":"2023-02-07","objectID":"/memo/2023/:0:8","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"其它 检索小技巧 搜索任意API文档 包名关键字+Java doc 1.下载任意网页的图标（favicon） 地址搜索栏：域名/favicon.ico Git疑难杂症 fetch-pack: unexpected disconnect while reading sideband packet early EOF unpack-objects failed 解决：git bash运行 git config --global pack.windowsMemory 256m docker docker run -d –name memos -p 8081:5230 -v E:/myStudySpace/Azad-Home/memoother/memos:/var/opt/memos ghcr.io/usememos/memos:latest ","date":"2023-02-07","objectID":"/memo/2023/:0:9","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 使用CSS重新设置现有控件的样式 组合现有控件来创建自定义控件 扩展现有控件 使用Control plus Skin类 使用Region类 前言\r上一篇文章展示了如何基于控件加皮肤方法创建自定义控件，这对于构建控件库非常有用。这一章将展示如何创建基于 JavaFX Region 类的 JavaFX 自定义控件； Region 类是所有 JavaFX 控件所基于的类。它是一个可调整大小的父节点，可以从 CSS 设置样式。这是您在构建不属于控件库的 JavaFX 自定义控件时希望使用的类。 ","date":"2023-02-05","objectID":"/customcontrols05/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（五）- 使用Region类来自定义全新的组件","uri":"/customcontrols05/"},{"categories":["JavaFx"],"content":"使用Region的实现类来自定义全新的组件 使用Region类的方法和基于 Control + Skin 的方法之间的主要区别在于：基于Region 的控件同时包含控制逻辑和 UI，而基于 Control + Skin 的控件将 逻辑与 UI 分开。逻辑可以在控件中找到，用户界面可以在皮肤中找到。 步骤1：将控件屏幕截图拖入到PS中，在截图上绘制控件副本 通过这种方法可以直接获得正确的屏幕尺寸、位置和颜色 演示\r步骤2：使用SVG矢量绘图程序手动绘制符号svg 将绘制好的符号路径添加到基于区域的控件的css代码中 ","date":"2023-02-05","objectID":"/customcontrols05/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（五）- 使用Region类来自定义全新的组件","uri":"/customcontrols05/"},{"categories":["JavaFx"],"content":"示例demo 信息\r自定义组合组件示例 ：一个可以通过点击右边按钮来让文本域切换相应的值的组合组件——实现℃和°F 的转换功能 正常状态\r`鼠标悬停前后`\r悬停状态\r更有趣的是我们需要创建的 CSS 文件，因为它包含了 UI 的所有“魔法”。所以这里是： .region-based { /* 预定义变量 */ -RED : #ff6058; -YELLOW : #ffbc35; -GREEN : #00c844; -GRAY : #535353; -DARK_GRAY: #343535; } .region-based .circle { -fx-stroke-width: 0.5px; } .region-based:close .circle, .region-based:close:hovered .circle { -fx-fill : -RED; /*derive(指定颜色, 在指定颜色基础上加深X%)*/ -fx-stroke: derive(-RED, -10%); } .region-based:close:pressed .circle { -fx-fill : derive(-RED, -20%); -fx-stroke: derive(-RED, -30%); } .region-based:minimize .circle, .region-based:minimize:hovered .circle { -fx-fill : -YELLOW; -fx-stroke: derive(-YELLOW, -5%); } .region-based:minimize:pressed .circle { -fx-fill : -YELLOW; -fx-stroke: derive(-YELLOW, -10%); } .region-based:zoom .circle, .region-based:zoom:hovered .circle { -fx-fill : -GREEN; -fx-stroke: derive(-GREEN, -10%); } .region-based:zoom:pressed .circle { -fx-fill : derive(-GREEN, -20%); -fx-stroke: derive(-GREEN, -30%); } .region-based:disabled:close .circle, .region-based:disabled:minimize .circle, .region-based:disabled:zoom .circle { -fx-fill : -GRAY; -fx-stroke: transparent; } .region-based:close .symbol, .region-based:minimize .symbol, .region-based:zoom .symbol { -fx-background-color: transparent; } .region-based:hovered:close .symbol { -fx-background-color: -DARK_GRAY; -fx-border-color : -DARK_GRAY; -fx-scale-shape : false; -fx-shape : \"M6.001,5.429l2.554,-2.555l0.571,0.571l-2.555,2.554l2.55,2.55l-0.572,0.572l-2.55,-2.55l-2.554,2.555l-0.571,-0.571l2.555,-2.554l-2.55,-2.55l0.572,-0.572l2.55,2.55Z\"; } .region-based:hovered:minimize .symbol { -fx-background-color: -DARK_GRAY; -fx-scale-shape : false; -fx-shape : \"M2.0,5.5l8,0l0,1l-8,0l0,-1Z\"; } .region-based:hovered:zoom .symbol { -fx-background-color: -DARK_GRAY; -fx-scale-shape : false; -fx-shape : \"M2.696,2.582l4.545,0.656l-3.889,3.889l-0.656,-4.545ZM9.533,9.418l-0.656,-4.545l-3.889,3.889l4.545,0.656Z\"; } .region-based:hovered:zoom:state .symbol { -fx-background-color: -DARK_GRAY; -fx-scale-shape : false; -fx-shape : \"M6.225,6.111L10.77,6.767L6.881,10.656L6.225,6.111ZM6.004,5.889L5.348,1.344L1.459,5.233L6.004,5.889Z\"; } 信息\r如前所述，我们知道我们需要的所有颜色，因此我们可以直接在我们的 CSS 文件中定义它们。我们有不同状态（-RED、-YELLOW、-GREEN）、禁用状态（-GRAY）和符号（-DARK_GRAY）的颜色。 原始的 MacOS 按钮看起来有一个内部阴影或一个比填充颜色暗一点的边框。为此，我们将描边设置为 0.5px。这也意味着我们必须定义比填充颜色深一点的描边颜色。 这可以通过使用 derive 方法在 JavaFX CSS 中轻松完成。如果我们想创建一个颜色较深的红色边框，我们可以按如下方式实现： -fx-stroke: derive(-RED, -10%); 此代码将根据为 -RED 定义的颜色创建一种颜色，该颜色比给定颜色深 10%。 package com.ryl.custom.regionBased; import javafx.beans.property.BooleanProperty; import javafx.beans.property.BooleanPropertyBase; import javafx.beans.property.ObjectProperty; import javafx.beans.property.ObjectPropertyBase; import javafx.css.PseudoClass; import javafx.scene.input.MouseEvent; import javafx.scene.layout.Region; import javafx.scene.shape.Circle; import javafx.scene.shape.StrokeType; import java.util.function.Consumer; /** * @author hansolo */ public class RegionControl extends Region { public enum Type {CLOSE, MINIMIZE, ZOOM} private static final double PREFERRED_WIDTH = 12; private static final double PREFERRED_HEIGHT = 12; private static final PseudoClass CLOSE_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"close\"); private static final PseudoClass MINIMIZE_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"minimize\"); private static final PseudoClass ZOOM_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"zoom\"); private static final PseudoClass HOVERED_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"hovered\"); private static final PseudoClass PRESSED_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"pressed\"); private static final PseudoClass STATE_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"state\"); private BooleanProperty hovered; private BooleanProperty state; private static String userAgentStyleSheet; private ObjectProperty\u003cType\u003e type; private double size; private double width; private double height; private Circle circle; private Region symbol; private Consumer\u003cMouseEvent\u003e","date":"2023-02-05","objectID":"/customcontrols05/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（五）- 使用Region类来自定义全新的组件","uri":"/customcontrols05/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part 5) HanSolo/JavaFXCustomControls(github) ","date":"2023-02-05","objectID":"/customcontrols05/:0:4","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（五）- 使用Region类来自定义全新的组件","uri":"/customcontrols05/"},{"categories":null,"content":"\r","date":"2023-02-02","objectID":"/memo/2024/:0:0","tags":null,"title":"2024","uri":"/memo/2024/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 使用CSS重新设置现有控件的样式 组合现有控件来创建自定义控件 扩展现有控件 使用Control plus Skin类 使用Region类 ","date":"2022-06-08","objectID":"/customcontrols04/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"使用Control plus Skin的实现类来自定义全新的组件 Control 将包含所有逻辑，而 Skin 将包含所有 UI 相关代码 步骤1：通过矢量绘图程序绘制好组件 演示\r步骤2：将矢量图形转换成css代码 步骤3：创建程序，引用css ","date":"2022-06-08","objectID":"/customcontrols04/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"示例demo 示例\r自定义全新组件示例 ：展示如何使用 Control 和 Skin 类在 JavaFX 中创建自定义控件—LED开关 注意： 由 Control 和 Skin 类创建的自定义控件只有在您为控件提供多个皮肤或者您希望让人们能够为您的控件创建自己的皮肤时才有意义。在任何其他情况下，您应该选择另一种方法（例如，使用基于区域或画布的控件）。因此，通常在 UI 库中使用 Control 和 Skin 方法，其中您有一个 Control 和多个 Skin。 LED\rpackage controlskin; import javafx.application.Application; import javafx.geometry.Insets; import javafx.scene.Scene; import javafx.scene.layout.VBox; import javafx.scene.paint.Color; import javafx.stage.Stage; import controlskin.CustomControl.SkinType; /** * @author Gerrit Grunwald * Description: 全新自定义组件程序demo */ public class DemoControlSkinBased extends Application { private CustomControl ledControl; private CustomControl switchControl; @Override public void init() throws Exception { ledControl = new CustomControl(); ledControl.setState(true); ledControl.setPrefSize(100, 100); ledControl.setColor(Color.LIME); switchControl = new CustomControl(SkinType.SWITCH); switchControl.setState(true); switchControl.setColor(Color.web(\"#4bd865\")); switchControl.stateProperty().addListener((o, ov, nv) -\u003e ledControl.setState(nv)); } @Override public void start(Stage stage) throws Exception { VBox pane = new VBox(20, ledControl, switchControl); pane.setPadding(new Insets(20)); Scene scene = new Scene(pane, 200, 200); scene.getStylesheets().add(DemoControlSkinBased.class.getResource(\"/styles.css\").toExternalForm()); stage.setTitle(\"Control-Skin based Control\"); stage.setScene(scene); stage.show(); } @Override public void stop() throws Exception { super.stop(); } } ","date":"2022-06-08","objectID":"/customcontrols04/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"Control 前言\r控件需要两个属性，第一个应该定义 LED 的状态，第二个应该定义 LED 的颜色; 众所周知，我们有能力在 JavaFX 中使用 CSS 来设置控件样式，问题是我们如何将 CSS 属性链接到我们在代码中定义的属性？ 答案是使用所谓的 StyleableProperties。这个属性有一个指向 CSS 属性的链接，这意味着如果我们加载一个覆盖例如 -color 属性的 CSS 文件，它将触发我们在代码中定义的属性。这很棒，因为我们可以通过在代码中调用 setColor() 方法或加载覆盖 -color 属性的 CSS 文件来更改属性； 最后，我们需要一个 BooleanProperty 来表示控件的状态。为此，我们还可以利用 JavaFX 中的 CSS 特性，即 CSS PseudoClass。这可以看作是一个布尔开关，如果在 CSS 中触发，则可用于为真/假状态定义单独的样式。 package controlskin; import javafx.beans.property.BooleanProperty; import javafx.beans.property.BooleanPropertyBase; import javafx.beans.property.ObjectProperty; import javafx.css.*; import javafx.scene.control.Control; import javafx.scene.control.Skin; import javafx.scene.paint.Color; import java.util.List; /** * @author Gerrit Grunwald * description：全新自定义的控件——实现功能：开关切换 */ public class CustomControl extends Control { public enum SkinType{ LED, SWITCH } private static final StyleablePropertyFactory\u003cCustomControl\u003e FACTORY = new StyleablePropertyFactory\u003c\u003e(Control.getClassCssMetaData()); /** css样式属性 **/ private static final CssMetaData\u003cCustomControl, Color\u003e COLOR = FACTORY.createColorCssMetaData(\"-color\", s -\u003e s.color, Color.RED, false); /** css伪类 **/ private static final PseudoClass ON_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"on\"); /** Properties **/ private SkinType skinType; private BooleanProperty state; private final StyleableProperty\u003cColor\u003e color; /** 用户代理样式表 **/ private static String defaultUserAgentStyleSheet; private static String switchUserAgentStyleSheet; /** * 构造器重载 */ public CustomControl() { this(SkinType.LED); } public CustomControl(final SkinType skinType){ getStyleClass().add(\"custom-control\"); this.skinType = skinType; this.state = new BooleanPropertyBase(false){ @Override protected void invalidated(){ pseudoClassStateChanged(ON_PSEUDO_CLASS,get()); } @Override public Object getBean() { return this; } @Override public String getName() { return \"state\"; } }; this.color = new SimpleStyleableObjectProperty\u003c\u003e(COLOR,this,\"color\"); } /** * state */ public boolean getState(){ return state.get(); } public void setState(final boolean state) { this.state.set(state); } public BooleanProperty stateProperty() { return state; } /** * color */ public Color getColor() { return color.getValue(); } public void setColor(final Color color){ this.color.setValue(color); } public ObjectProperty\u003cColor\u003e colorProperty(){ return (ObjectProperty\u003cColor\u003e) color; } /** * style related */ @Override protected Skin\u003c?\u003e createDefaultSkin() { switch (skinType){ case SWITCH: return new SwitchSkin(CustomControl.this); case LED: default: return new LedSkin(CustomControl.this); } } @Override public String getUserAgentStylesheet() { switch(skinType) { case SWITCH: if (null == switchUserAgentStyleSheet) { switchUserAgentStyleSheet = CustomControl.class.getResource(\"/switch.css\").toExternalForm(); } return switchUserAgentStyleSheet; case LED : default : if (null == defaultUserAgentStyleSheet) { defaultUserAgentStyleSheet = CustomControl.class.getResource(\"/custom-control.css\").toExternalForm(); } return defaultUserAgentStyleSheet; } } @Override public List\u003cCssMetaData\u003c? extends Styleable, ?\u003e\u003e getControlCssMetaData() { return FACTORY.getCssMetaData(); } } 总结\r通过css样式属性定义了一个名为COLOR的 CssMetaData 对象，而这个对象又定义了将在 CSS 中使用的属性-color； 再去css文件中定义这个属性，比如紫色部分： .custom-control { -color: red; } PseudoClass ON_PSEUDO_CLASS 定义了到 CSS 伪类“on”的链接，为了使用它，我们通过调用 pseudoClassStateChanged(ON_PSEUDO_CLASS.get()) 在 state 属性的 invalidated() 方法中触发它; 为了完成这项工作，我们还需要 CSS 文件中的 on 伪类。请记住，主要 LED 部分（绿色部分）是在 LED 亮起时应从深绿色渐变变为浅绿色渐变的部分。下面是实现此效果所需的 CSS 代码： .custom-control .main { -fx-background-color : linear-gradient(from 15% 15% to 83% 83%, derive(-color, -80%) 0%, derive(-color, -87%) 49%, derive(-color, -80%) 100%); -fx-background-radius: 1024px; } .custom-control:on .main { -fx-background-color: linear-gradient(from 15% 15% to 83% 83%, derive(-color, -23%) 0%, derive(-color, -50%) 49%, -color 100%); } 我们定义了一个具有 LED 和 SWITCH 的枚举 SkinType，它们将在 getUserAgentStyleSheet() 方法中使用。根据 skinType 变量加载不同的样式表","date":"2022-06-08","objectID":"/customcontrols04/:0:4","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"Skin LED package controlskin; import javafx.beans.InvalidationListener; import javafx.scene.control.SkinBase; import javafx.scene.effect.BlurType; import javafx.scene.effect.DropShadow; import javafx.scene.effect.InnerShadow; import javafx.scene.layout.Region; import javafx.scene.paint.Color; /** * @author Gerrit Grunwald * description：led皮肤 */ public class LedSkin extends SkinBase\u003cCustomControl\u003e { private static final double PREFERRED_WIDTH = 16; private static final double PREFERRED_HEIGHT = 16; private static final double MINIMUM_WIDTH = 8; private static final double MINIMUM_HEIGHT = 8; private static final double MAXIMUM_WIDTH = 1024; private static final double MAXIMUM_HEIGHT = 1024; private double size; /** 组件 **/ private Region frame; private Region main; private Region highlight; private InnerShadow innerShadow; private DropShadow glow; /** 自定义组件 **/ private CustomControl control; /** 监听器 **/ private final InvalidationListener sizeListener; private final InvalidationListener colorListener; private final InvalidationListener stateListener; /** * 构造器 * @param control 自定义组件 */ public LedSkin(final CustomControl control) { super(control); this.control = control; sizeListener = o -\u003e handleControlPropertyChanged(\"RESIZE\"); colorListener = o -\u003e handleControlPropertyChanged(\"COLOR\"); stateListener = o -\u003e handleControlPropertyChanged(\"STATE\"); initGraphics(); registerListeners(); } /** * 初始化 */ private void initGraphics() { if (Double.compare(control.getPrefWidth(), 0.0) \u003c= 0 || Double.compare(control.getPrefHeight(), 0.0) \u003c= 0 || Double.compare(control.getWidth(), 0.0) \u003c= 0 || Double.compare(control.getHeight(), 0.0) \u003c= 0) { if (control.getPrefWidth() \u003e 0 \u0026\u0026 control.getPrefHeight() \u003e 0) { control.setPrefSize(control.getPrefWidth(), control.getPrefHeight()); } else { control.setPrefSize(PREFERRED_WIDTH, PREFERRED_HEIGHT); } } frame = new Region(); frame.getStyleClass().setAll(\"frame\"); main = new Region(); main.getStyleClass().setAll(\"main\"); main.setStyle(String.join(\"\", \"-color: \", control.getColor().toString().replace(\"0x\", \"#\"), \";\")); innerShadow = new InnerShadow(BlurType.TWO_PASS_BOX, Color.rgb(0, 0, 0, 0.65), 8, 0, 0, 0); glow = new DropShadow(BlurType.TWO_PASS_BOX, control.getColor(), 20, 0, 0, 0); glow.setInput(innerShadow); highlight = new Region(); highlight.getStyleClass().setAll(\"highlight\"); getChildren().addAll(frame, main, highlight); } /** * 添加监听器 */ private void registerListeners() { control.widthProperty().addListener(sizeListener); control.heightProperty().addListener(sizeListener); control.colorProperty().addListener(colorListener); control.stateProperty().addListener(stateListener); } @Override protected double computeMinWidth(final double height, final double top, final double right, final double bottom, final double left) { return MINIMUM_WIDTH; } @Override protected double computeMinHeight(final double width, final double top, final double right, final double bottom, final double left) { return MINIMUM_HEIGHT; } @Override protected double computePrefWidth(final double height, final double top, final double right, final double bottom, final double left) { return super.computePrefWidth(height, top, right, bottom, left); } @Override protected double computePrefHeight(final double width, final double top, final double right, final double bottom, final double left) { return super.computePrefHeight(width, top, right, bottom, left); } @Override protected double computeMaxWidth(final double width, final double top, final double right, final double bottom, final double left) { return MAXIMUM_WIDTH; } @Override protected double computeMaxHeight(final double width, final double top, final double right, final double bottom, final double left) { return MAXIMUM_HEIGHT; } /** * 处理控件属性变化 */ protected void handleControlPropertyChanged(final String property) { if (\"RESIZE\".equals(property)) { resize(); } else if (\"COLOR\".equals(property)) { main.setStyle(String.join(\"\", \"-color: \", (control.getColor()).toString().repla","date":"2022-06-08","objectID":"/customcontrols04/:0:5","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"CSS LED .custom-control .frame { -fx-background-color : linear-gradient(from 14% 14% to 84% 84%, rgba(20, 20, 20, 0.64706) 0%, rgba(20, 20, 20, 0.64706) 15%, rgba(41, 41, 41, 0.64706) 26%, rgba(200, 200, 200, 0.40631) 85%, rgba(200, 200, 200, 0.3451) 100%); -fx-background-radius: 1024px; } .custom-control .main { -fx-background-color : linear-gradient(from 15% 15% to 83% 83%, derive(-color, -80%) 0%, derive(-color, -87%) 49%, derive(-color, -80%) 100%); -fx-background-radius: 1024px; } .custom-control:on .main { -fx-background-color: linear-gradient(from 15% 15% to 83% 83%, derive(-color, -23%) 0%, derive(-color, -50%) 49%, -color 100%); } .custom-control .highlight { -fx-background-color : radial-gradient(center 15% 15%, radius 50%, white 0%, transparent 100%); -fx-background-radius: 1024; } 总结\r在该CSS 文件中，实际上只是定义了每个区域的背景半径和始终为渐变的绘制； 通过触发 :on 伪类，我们只会将渐变从较暗的版本更改为较亮的版本，仅此而已。 Switch .custom-control .switch-background { -fx-pref-width : 76; -fx-pref-height : 46; -fx-min-width : 76; -fx-min-height : 46; -fx-max-width : 76; -fx-max-height : 46; -fx-background-radius: 1024; -fx-background-color : #a3a4a6; } .custom-control:on .switch-background { -fx-background-radius: 1024; -fx-background-color : -color; } .custom-control .thumb { -fx-translate-x : 2; -fx-translate-y : 2; -fx-pref-width : 42; -fx-pref-height : 42; -fx-min-width : 42; -fx-min-height : 42; -fx-max-width : 42; -fx-max-height : 42; -fx-background-radius: 1024; -fx-background-color : white; -fx-effect : dropshadow(two-pass-box, rgba(0, 0, 0, 0.3), 1, 0.0, 0, 1); } Styles 演示\r.custom-control { -color: magenta; } 技巧\r通过添加场景样式表覆盖 CSS 文件中的一个属性-color，控件属性就会被覆盖，而无需更改代码，这显示了 CSS 的强大功能： scene.getStylesheets().add(ClassNameHere.class.getResource(\"/styles.css\").toExternalForm()); .custom-control { -color: magenta; } ","date":"2022-06-08","objectID":"/customcontrols04/:0:6","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part 4) HanSolo/JavaFXCustomControls(github) adobe illustrator to CSS——矢量绘图程序：视觉编码之操作文档 ","date":"2022-06-08","objectID":"/customcontrols04/:0:7","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 使用CSS重新设置现有控件的样式 组合现有控件来创建自定义控件 扩展现有控件 使用Control + Skin类 使用Region类 ","date":"2022-06-06","objectID":"/customcontrols03/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（三）- 扩展现有控件来创建自定义控件","uri":"/customcontrols03/"},{"categories":["JavaFx"],"content":"扩展现有控件来生成自定义控件 示例\r自定义扩展组件示例 ：根据焦点状态添加文本的动画组件\r成果\rpackage extended; import javafx.application.Application; import javafx.application.Platform; import javafx.geometry.Insets; import javafx.scene.Scene; import javafx.scene.control.Button; import javafx.scene.layout.VBox; import javafx.stage.Stage; /** * @author Gerrit Grunwald */ public class DemoExtended extends Application { private ExtendedControl control; private Button button; @Override public void init() { control = new ExtendedControl(); control.setPromptText(\"Name\"); button = new Button(\"Focus\"); } @Override public void start(final Stage stage) { VBox pane = new VBox(24, control, button); pane.setPadding(new Insets(20)); Scene scene = new Scene(pane); stage.setTitle(\"Extended\"); stage.setScene(scene); stage.show(); button.requestFocus(); } @Override public void stop() { Platform.exit(); System.exit(0); } public static void main(String[] args) { launch(args); } } package extended; import javafx.animation.KeyFrame; import javafx.animation.KeyValue; import javafx.animation.Timeline; import javafx.beans.property.DoubleProperty; import javafx.beans.property.ObjectProperty; import javafx.beans.property.SimpleDoubleProperty; import javafx.css.*; import javafx.scene.control.TextField; import javafx.scene.layout.HBox; import javafx.scene.paint.Color; import javafx.scene.text.Font; import javafx.scene.text.Text; import javafx.util.Duration; import java.util.List; /** * @author Gerrit Grunwald * Here are the things we need to do... * * 1.Extend the JavaFX TextField * 2.Add a Text to it that can be set using the promptTextProperty * 3.Add animation of the Text dependent on the focus state * 4.Add some CSS styling */ public class ExtendedControl extends TextField { private static final StyleablePropertyFactory\u003cExtendedControl\u003e FACTORY = new StyleablePropertyFactory\u003c\u003e(TextField.getClassCssMetaData()); private static final double STD_FONT_SIZE = 13; private static final double SMALL_FONT_SIZE = 10; private static final double TOP_OFFSET_Y = 4; private static final int ANIMATION_DURATION = 60; /** 组件 **/ private Text promptText; private HBox promptTextBox; /** paint **/ private static final Color DEFAULT_MATERIAL_DESIGN_COLOR = Color.web(\"#009688\"); private static final Color DEFAULT_PROMPT_TEXT_COLOR = Color.web(\"#757575\"); /** 动画时间线 **/ private Timeline timeline; /** Properties **/ private final StyleableProperty\u003cColor\u003e materialDesignColor; private final StyleableProperty\u003cColor\u003e promptTextColor; private DoubleProperty fontSize; /** 用户代理样式表 **/ private static String userAgentStyleSheet; /** css样式属性 **/ private static final CssMetaData\u003cExtendedControl, Color\u003e MATERIAL_DESIGN_COLOR = FACTORY.createColorCssMetaData (\"-material-design-color\", s -\u003e s.materialDesignColor, DEFAULT_MATERIAL_DESIGN_COLOR, false); private static final CssMetaData\u003cExtendedControl, Color\u003e PROMPT_TEXT_COLOR = FACTORY.createColorCssMetaData (\"-prompt-text-color\", s -\u003e s.promptTextColor, DEFAULT_PROMPT_TEXT_COLOR, false); public ExtendedControl() { this(\"\"); } public ExtendedControl(final String promptTextBox) { super(promptTextBox); materialDesignColor = new SimpleStyleableObjectProperty\u003c\u003e(MATERIAL_DESIGN_COLOR, this, \"materialDesignColor\"); promptTextColor = new SimpleStyleableObjectProperty\u003c\u003e(PROMPT_TEXT_COLOR, this, \"promptTextColor\"); fontSize = new SimpleDoubleProperty(ExtendedControl.this, \"fontSize\", getFont().getSize()); timeline = new Timeline(); initGraphics(); registerListeners(); } /** * 初始化 */ private void initGraphics() { getStyleClass().addAll(\"material-field\"); final String fontFamily = getFont().getFamily(); final int length = getText().length(); promptText = new Text(getPromptText()); promptText.getStyleClass().add(\"prompt-text\"); promptTextBox = new HBox(promptText); promptTextBox.getStyleClass().add(\"material-field\"); if (!isEditable() || isDisabled() || length \u003e 0) { promptText.setFont(Font.font(fontFamily, SMALL_FONT_SIZE)); promptTextBox.setTranslateY(-STD_FONT_SIZE - TOP_OFFSET_Y); } else { pro","date":"2022-06-06","objectID":"/customcontrols03/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（三）- 扩展现有控件来创建自定义控件","uri":"/customcontrols03/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part 3) HanSolo/JavaFXCustomControls(github) ","date":"2022-06-06","objectID":"/customcontrols03/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（三）- 扩展现有控件来创建自定义控件","uri":"/customcontrols03/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 使用CSS重新设置现有控件的样式 组合现有控件来创建自定义控件 扩展现有控件 使用Control + Skin类 使用Region类 ","date":"2022-06-06","objectID":"/customcontrols02/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（二）- 组合现有控件来创建自定义控件","uri":"/customcontrols02/"},{"categories":["JavaFx"],"content":"组合现有控件来创建自定义控件 示例\r自定义组合组件示例 ：一个可以通过点击右边按钮来让文本域切换相应的值的组合组件——实现℃和°F 的转换功能 添加css样式表前\r`添加css样式表前后`\r添加css样式表后\rpackage extended; import javafx.application.Application; import javafx.application.Platform; import javafx.geometry.Insets; import javafx.scene.Scene; import javafx.scene.control.Button; import javafx.scene.layout.VBox; import javafx.stage.Stage; /** * @author Gerrit Grunwald */ public class DemoExtended extends Application { private ExtendedControl control; private Button button; @Override public void init() { control = new ExtendedControl(); control.setPromptText(\"Name\"); button = new Button(\"Focus\"); } @Override public void start(final Stage stage) { VBox pane = new VBox(24, control, button); pane.setPadding(new Insets(20)); Scene scene = new Scene(pane); stage.setTitle(\"Extended\"); stage.setScene(scene); stage.show(); button.requestFocus(); } @Override public void stop() { Platform.exit(); System.exit(0); } public static void main(String[] args) { launch(args); } } package comb; import javafx.geometry.Pos; import javafx.scene.control.Button; import javafx.scene.control.TextField; import javafx.scene.control.TextFormatter; import javafx.scene.layout.HBox; import java.util.Locale; /** * @author Azad-eng * Description: 组合组件类——由TextField和Button组成的自定义实现特定功能的HBox组件, * 作用是实现摄氏度和华氏度的值的转换 */ public class CombinedControl extends HBox { private TextField textField; private Button button; public CombinedControl() { init(); getStyleClass().setAll(\"combined-control\"); registerListeners(); } private void init() { textField = new TextField(); textField.setFocusTraversable(false); textField.setTextFormatter( new TextFormatter\u003c\u003e(change -\u003e change.getText().matches(\"[0-9]*(\\\\.[0-9]*)?\") ? change : null)); button = new Button(\"°C\"); button.setFocusTraversable(false); setSpacing(0); setFillHeight(false); setAlignment(Pos.CENTER); getChildren().addAll(textField, button); } private void registerListeners() { button.setOnMousePressed(e -\u003e handleControlPropertyChanged(\"BUTTON_PRESSED\")); } private void handleControlPropertyChanged(final String PROPERTY) { if (\"BUTTON_PRESSED\".equals(PROPERTY)) { String buttonText = button.getText(); String text = textField.getText(); if (text.matches(\"^[-+]?\\\\d+(\\\\.\\\\d+)?$\")) { if (\"°C\".equals(buttonText)) { // Convert to Fahrenheit button.setText(\"°F\"); textField.setText(toFahrenheit(textField.getText())); } else { // Convert to Celsius button.setText(\"°C\"); textField.setText(toCelsius(textField.getText())); } } } } private String toFahrenheit(final String text) { try { double celsius = Double.parseDouble(text); return String.format(Locale.US, \"%.2f\", (celsius * 1.8 + 32)); } catch (NumberFormatException e) { return text; } } private String toCelsius(final String text) { try { double fahrenheit = Double.parseDouble(text); return String.format(Locale.US, \"%.2f\", ((fahrenheit - 32) / 1.8)); } catch (NumberFormatException e) { return text; } } } /*这是样式表，让控件内部的两个小组件视觉上仿若一体*/ .combined-control:focused { -fx-highlight-fill : -fx-accent; -fx-background-color : -fx-focus-color, -fx-control-inner-background, -fx-faint-focus-color; -fx-background-insets: -1.2, 1, -2.4; -fx-background-radius: 3, 2, 4, 0; -fx-border-color : -fx-faint-focus-color; -fx-border-insets : -1; } .combined-control:focused \u003e .button { -fx-background-color : -fx-focus-color, -fx-outer-border, -fx-inner-border, -fx-body-color, -fx-faint-focus-color, -fx-body-color; -fx-background-insets: -0.2 -0.2 -0.2 1, 1 1 1 0, 1 1 1 1, 2, -1.4 -1.4 -1.4 1, 2.6; -fx-background-radius: 0 3 3 0, 0 2 2 0, 0 1 1 0, 0 4 4 0, 0 1 1 0; } .combined-control \u003e .text-input, .combined-control \u003e .text-input:focused { -fx-background-color : linear-gradient(to bottom, derive(-fx-text-box-border, -10%), -fx-text-box-border), linear-gradient(from 0px 0px to 0px 5px, derive(-fx-control-inner-background, -9%), -fx-control-inner-background); -fx-background-insets : 0, 1 0 1 1; -fx-background-radius : 3 0 0 3, 2 0 0 2; -fx-pref-width : 120px; } .combined-control \u003e .button { -fx-backgr","date":"2022-06-06","objectID":"/customcontrols02/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（二）- 组合现有控件来创建自定义控件","uri":"/customcontrols02/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part 2) HanSolo/JavaFXCustomControls(github) ","date":"2022-06-06","objectID":"/customcontrols02/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（二）- 组合现有控件来创建自定义控件","uri":"/customcontrols02/"},{"categories":["JavaFx"],"content":"前言 为什么需要自定义控件？\rJavaFx中很多内置控件的代码都是私有的或最终的，因此无法访问或覆盖它们的内部结构，当涉及到个性化的需求时，就会束手无策 当需要定制一个全新的符合项目需求的组件，而JavaFX中内置的组件无法满足需求 ","date":"2022-06-06","objectID":"/customcontrols01/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 使用CSS重新设置现有控件的样式 组合现有控件来创建自定义控件 扩展现有控件 使用Control + Skin类 使用Region类 ","date":"2022-06-06","objectID":"/customcontrols01/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"具体实现 步骤1：在 modena.css 文件中获取指定控件的css样式 modena.css 是包含JavaFx内置的每个控件的所有css样式的文件，其前身是 caspian.css，但进行了许多优化。 【:\u003e JFoenix-css是包含JFoenix包里每个控件的所有css样式的文件，是对JavaFx控件的扩展。】 步骤2：复制指定控件样式至新的css文件中 步骤3：修改JavaFX CSS 如果不熟悉 JavaFX 中使用的 CSS 变体，可以说看看JavaFX CSS 参考指南 。 它是一个非常强大的工具，可以设置/重新设置控件的样式。原则上，它与 web CSS 非常相似，除了它基于 CSS 2.1，所有属性都以“-fx-”为前缀，并且它有一些特殊的东西，比如对变量的内置支持等。 步骤4：覆盖项目中的控件样式 方法A: 样式表覆盖 样式表从 Scene 对象的 getStylesheets 属性中指定的 URL 加载，比如 scene.getStylesheets().add(ClassNameHere.class.getResource(\"/styles/restyled.css\").toExternalForm()); 方法B：内联样式覆盖 内联样式通过在fxml文件首行添加 Node setStyle API 指定，比如 stylesheets=\"@../../styles/restyled.css\" 注意\r样式选择器的优先顺序： 内联样式\u003e场景样式表\u003e用户代理样式表(默认) 样式选择器的优先顺序可以在样式声明中使用“！important”进行修改 ","date":"2022-06-06","objectID":"/customcontrols01/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"实例 成果\r* Here are the things we need to do... * * 1.No gradients which leads to a more flat ui * 2.Different kind of checkmark * 3.Background filled when selected * 4.Different focus indicator /** 在组件CheckBox的css默认类check-box上做改动 **/ .check-box { -material-design-color : #3f51b5; -material-design-color-transparent-12: #3f51b51f; -material-design-color-transparent-24: #3f51b53e; -material-design-color-transparent-40: #3f51b566; -fx-font-family : \"Arial\"; /* Roboto Regular */ -fx-font-size : 13px; -fx-label-padding: 0em 0em 0em 1.1em; -fx-text-fill : -fx-text-background-color; } .check-box \u003e .box { -fx-background-color : transparent; -fx-background-insets : 0; -fx-border-color : #0000008a; -fx-border-width : 2px; -fx-border-radius : 2px; -fx-padding : 0.083333em; /* 1px */ -fx-text-fill : -fx-text-base-color; -fx-alignment : CENTER; -fx-content-display : LEFT; } .check-box:hover \u003e .box { -fx-background-color : #61616110, transparent; -fx-background-insets : -14, 0; -fx-background-radius : 1024; -fx-cursor : hand; } .check-box:focused \u003e .box { /* -fx-background-color : #6161613e, transparent;*/ -fx-background-insets : -14, 0; -fx-background-radius : 1024; } .check-box:pressed \u003e .box { -fx-background-color : -material-design-color-transparent-12, transparent; -fx-background-insets : -14, 0; -fx-background-radius : 1024; } .check-box:selected \u003e .box { -fx-background-color : -material-design-color; -fx-background-radius : 2px; -fx-background-insets : 0; -fx-border-color : transparent; } .check-box:selected:hover \u003e .box { -fx-background-color : -material-design-color-transparent-12, -material-design-color; -fx-background-insets : -14, 0; -fx-background-radius : 1024, 2px; -fx-border-color : transparent; -fx-cursor : hand; } .check-box:selected:focused \u003e .box { -fx-background-color : -material-design-color-transparent-24, -material-design-color; -fx-background-insets : -14, 0; -fx-background-radius : 1024, 2px; -fx-border-color : transparent; } .check-box:disabled { -fx-opacity: 0.46; } .check-box \u003e .box \u003e .mark { -fx-background-color: null; -fx-padding : 0.45em; -fx-scale-x : 1.1; -fx-scale-y : 0.8; -fx-shape : \"M-0.25,6.083c0.843-0.758,4.583,4.833,5.75,4.833S14.5-1.5,15.917-0.917c1.292,0.532-8.75,17.083-10.5,17.083C3,16.167-1.083,6.833-0.25,6.083z\"; } .check-box:indeterminate:hover \u003e .box { cursor:hand; } .check-box:indeterminate \u003e .box { -fx-background-color : -material-design-color-transparent-40; -fx-background-radius : 2px; -fx-background-insets : 0; -fx-border-color : transparent; } .check-box:indeterminate \u003e .box \u003e .mark { -fx-background-color: rgba(255, 255, 255, 0.87); -fx-shape : \"M0,0H10V2H0Z\"; -fx-scale-shape: false; -fx-padding : 0.666667em; } .check-box:selected \u003e .box \u003e .mark { -fx-background-color : rgba(255, 255, 255, 0.87); -fx-background-insets: 0; } /** 新建一个css类switch覆盖组件CheckBox的css默认类check-box **/ .switch { -material-design-color : #3f51b5; -material-design-color-transparent-12: #3f51b51f; -material-design-color-transparent-24: #3f51b53e; -material-design-color-transparent-40: #3f51b566; -fx-font-family : \"Arial\"; -fx-font-size : 13.0px; -fx-label-padding: 0em 0em 0em 1.1em; -fx-text-fill : -fx-text-background-color; } .switch \u003e *.box { -fx-background-color : #00000066; -fx-pref-height : 20; -fx-pref-width : 40; -fx-background-radius: 1024px; -fx-background-insets: 2.5; -fx-padding : 0; } .switch:selected \u003e *.box { -fx-background-color: -material-design-color-transparent-40; } .switch:disabled \u003e *.box { -fx-background-color: #0000001f; } .switch \u003e *.box \u003e *.mark { -fx-background-color : fafafa; -fx-padding : 0; -fx-background-insets: 0 10 0 10; -fx-background-radius: 1024px; -fx-translate-x : -8px; -fx-effect : dropshadow(gaussian, rgba(0, 0, 0, 0.3), 4.0, 0.5, 0.0, 1); } .switch:hover \u003e *.box \u003e *.mark { -fx-background-color : #61616110, white; -fx-background-insets: -14 -4 -14 -4, 0 10 0 10; -fx-background-radius: 1024px, 1024px; -fx-effect : dropshadow(gaussian, rgba(0, 0, 0, 0.3), 4.0, 0.2, 0.0, 1); } .switch:s","date":"2022-06-06","objectID":"/customcontrols01/:0:4","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"扩展 如何将自定义控件导入场景生成器？\r要将自定义控件导入 SceneBuilder，需要从控件创建一个 jar 并将此 jar 添加到 Library 文件夹。在 SceneBuilder中有一个可以单击的小齿轮图标。它的弹出菜单有一个名为“自定义库文件夹”的条目，其中有一个条目可以让您在资源管理器或查找器（取决于您的操作系统）中打开库文件夹。如果将创建的 jar 复制到此文件夹中，组件应出现在 Scene Builder 的“自定义”选项卡中。\r","date":"2022-06-06","objectID":"/customcontrols01/:0:5","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part I) HanSolo/JavaFXCustomControls(github) JavaFX CSS 参考指南(API) ","date":"2022-06-06","objectID":"/customcontrols01/:0:6","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["Java多线程与并发"],"content":"\r技巧：带着问题去学习与理解Synchronized\rSynchronized可以作用在哪里?分别通过对象锁和类锁进行举例。 （✔） Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。 Synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的。 Synchronized和Lock的对比，和选择? Synchronized在使用时有何注意事项? Synchronized修饰的方法在抛出异常时,会释放锁吗? 多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程? Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法? 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办? 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁? 不同的JDK中对Synchronized有何优化? ","date":"2022-06-02","objectID":"/synchronized/:0:0","tags":["Synchronized关键字","Java同步代码"],"title":"关键字Synchronized的运用","uri":"/synchronized/"},{"categories":["Java多线程与并发"],"content":"一、Synchronized的使用场景 synchronized(重量级锁，对系统性能影响较大) 最常用于多线程并发编程时线程的同步。 synchronized可以修饰普通方法，静态方法和代码块。当synchronized修饰一个方法或者一个代码块的时候，它能够保证在同一时刻最多只有一个线程执行该段代码。 对于普通同步方法，锁是当前实例对象（不同实例对象之间的锁互不影响）。 对于静态同步方法，锁是当前类的Class对象。 对于同步代码块，锁是Synchonized括号里配置的对象。 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。 对象锁 应用于普通方法和代码块的同步 同步普通方法 public class UseSynchronized implements Runnable { static UseSynchronized instance = new UseSynchronized(); @Override public void run() { invokeMe(); } synchronized public void invokeMe(){ System.out.println(\"线程\" + Thread.currentThread().getName() + \"开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"结束\"); } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(instance); thread.start(); } } } 控制台输出：\routput\r注意\rsynchronized修饰普通方法时，默认的锁就是this对象锁，即当前实例对象锁\r同步代码块—this 即默认锁对象为当前实例对象 public class UseSynchronized implements Runnable { static UseSynchronized instance = new UseSynchronized(); @Override public void run() { //多个线程使用的锁是一样的,线程必须要等上一个线程释放锁后才能执行 synchronized (this) { System.out.println(\"线程\" + Thread.currentThread().getName() + \"开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"结束\"); } } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(instance); thread.start(); } } } 控制台输出：\routput\r注意\rthis指当前实例对象，所以synchronized (this)只能在多个线程作用于同一个实例对象时才能发挥作用。\r同步代码块—自定义锁 即自己手动创建锁：Object lock = new Object() /** * @author Azad-eng * Description:因为第二段代码块的锁与第一段代码块不一样，所以不会等到所有线程全部执行完第一段代码块后才执行第二段代码块 */ public class UseSynchronized implements Runnable { static UseSynchronized instance = new UseSynchronized(); //手动创建两把锁 Object lock1 = new Object(); Object lock2 = new Object(); @Override public void run() { synchronized (lock1) { System.out.println(\"线程\" + Thread.currentThread().getName() + \"拿到lock1锁后开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"释放lock1锁后结束\"); } synchronized (lock2) { System.out.println(\"线程\" + Thread.currentThread().getName() + \"拿到lock2锁后开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"释放lock2锁后结束\"); } } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(instance); thread.start(); } } } 控制台输出：\routput\r类锁 应用于静态方法的同步或指定锁对象为class对象 # 同步静态方法 public class UseSynchronized implements Runnable { @Override public void run() { invokeMe(); } static synchronized public void invokeMe(){ System.out.println(\"线程\" + Thread.currentThread().getName() + \"开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"结束\"); } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(new UseSynchronized()); thread.start(); } } } 控制台输出：\routput\r注意\r不同于普通方法只能作用于同一实例对象，修饰静态方法的synchronized可以保证不同实例对象的线程也能在执行方法时得到同步\r# 指定对象锁为class对象 public class UseSynchronized implements Runnable { @Override public void run() { //所有线程需要的锁都是同一把 synchronized (UseSynchronized.class) { System.out.println(\"线程\" + Thread.currentThread().getName() + \"开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" + Thread.currentThread().getName() + \"结束\"); } } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(new UseSynchronized()); thread.start(); } } } 控制台输出：\routput\r","date":"2022-06-02","objectID":"/synchronized/:0:1","tags":["Synchronized关键字","Java同步代码"],"title":"关键字Synchronized的运用","uri":"/synchronized/"},{"categories":["Java多线程与并发"],"content":"二、Synchronized使用注意事项 使用Synchronized有哪些要注意的？ 锁对象不能为空，因为锁的信息都保存在对象头里 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错 避免死锁 在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错 synchronized是公平锁吗？ synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。 ","date":"2022-06-02","objectID":"/synchronized/:0:2","tags":["Synchronized关键字","Java同步代码"],"title":"关键字Synchronized的运用","uri":"/synchronized/"},{"categories":["Java多线程与并发"],"content":"参考链接： Java 全栈知识体系之关键字: synchronized详解 程序员自由之路之synchronized 的使用场景和原理简介 ","date":"2022-06-02","objectID":"/synchronized/:0:3","tags":["Synchronized关键字","Java同步代码"],"title":"关键字Synchronized的运用","uri":"/synchronized/"},{"categories":["Java基础"],"content":"Java创建对象并通过对象访问属性的可视化流程及对象拷贝","date":"2022-06-02","objectID":"/classvisulize/","tags":["java基础","Java Visualizer"],"title":"ClassVisulize","uri":"/classvisulize/"},{"categories":["Java基础"],"content":"\r","date":"2022-06-02","objectID":"/classvisulize/:0:0","tags":["java基础","Java Visualizer"],"title":"ClassVisulize","uri":"/classvisulize/"},{"categories":["Java基础"],"content":"Java创建对象并调用方法的可视化流程","date":"2022-06-02","objectID":"/methodvisualize/","tags":["java基础","Java Visualizer"],"title":"MethodVisualize","uri":"/methodvisualize/"},{"categories":["Java基础"],"content":"\r","date":"2022-06-02","objectID":"/methodvisualize/:0:0","tags":["java基础","Java Visualizer"],"title":"MethodVisualize","uri":"/methodvisualize/"},{"categories":["Java基础","网络通讯"],"content":"\rBIO和NIO的不同\rBIO以流的方式处理数据，而NIO以块的方式处理数据，后者效率高很多 BIO是阻塞的，而NIO是非阻塞的 BIO是基于字节流和字符流进行数据操作，且只能单向操作，即要么读取inputStream要么写出outputStream，而NIO基于Channel(通道)和Buffer(缓冲区)进行数据操作的，Buffer既可以读取get()也可以写入数据put()，只需通过flip进行读写切换即可,Channel也是双向的，可以返回底层OS的情况 BIO一个线程只能监听一个客户端，而BIO的Selector(选择器)可以用于监听多个通道的事件(比如：连接请求),因此使用单个线程就可以监听多个客户端通道 IoModel (nio\u0026bio)\r","date":"2022-06-01","objectID":"/iomodel/:0:0","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["Java基础","网络通讯"],"content":"演示BIO服务端线程池机制 package com.efl.bio; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Author: Azad-eng * Date: 2022/2/26 * Description: 演示线程池机制 */ public class BioServer { public static void main(String[] args) throws IOException { /** * 思路分析： * 1.创建一个线程池 * 2.如果有客户端连接，就创建一个线程与之通信(单独写一个方法) */ ExecutorService threadPool = Executors.newCachedThreadPool(); ServerSocket serverSocket = new ServerSocket(6666); while (true) { //监听，等待客户端连接,得到一个不可更改的Socket //如果没有连接会堵塞在这里 System.out.println(\"server has started, accepting...\"); Socket socket = serverSocket.accept(); System.out.println(\"连接到一个client了！\"); //执行线程池里new出来的线程，重写里面的run方法 threadPool.execute(new Runnable() { @Override public void run() { //这里就可以和客户端通信了，单独写一个通信的方法，把客户端连接上的socket传进去(没有这个socket无法进行通信) //调用该方法handler(socket)进行通信 //测试线程信息 System.out.println( \"启动了线程:id=\" + Thread.currentThread().getId() + \" name=\" + Thread.currentThread().getName() + \"\\n可以进行通信了！\"); handler(socket); } }); } } public static void handler(Socket socket) { try { //建立一个容量为1024的字节数组来接收数据 byte[] bytes = new byte[1024]; InputStream inputStream = socket.getInputStream(); //持续读取client发送的数据(该数据被装在了bytes字节数组中) while (true) { //read()方法返回的是接收的data的下一个byte(类型为int),如果返回-1代表inputStream到底了 //与NIO不同的是：如果服务端没有接收到客户端发出的数据线程会堵塞在这里 System.out.println(\"reading...\"); int read = inputStream.read(bytes); if (read != -1) { //把读取到的数据(字节数组——\u003e字符串)print出来 System.out.println(new String(bytes, 0, read)); } else { //程序执行到这里代表数据读取到底了，那么就退出while循环，接着关闭流，退出通信 break; } } } catch (IOException e) { e.printStackTrace(); } finally { try { System.out.println(\"线程:id=\" + Thread.currentThread().getId() + \" name=\" + Thread.currentThread().getName() +\"关闭了和server的连接\"); socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } ","date":"2022-06-01","objectID":"/iomodel/:0:1","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["Java基础","网络通讯"],"content":"演示NIO核心组件之一Buffer的使用 package com.efl.nio; import java.nio.IntBuffer; /** * Author: Azad-eng * Date: 2022/2/26 * Description:演示NIO核心组件之一Buffer的使用 */ public class BasicBuffer { public static void main(String[] args) { /** * 思路分析： * 1.创建一个IntBuffer,容量为5个int * 2.向里面存放数据10,11,12,13,14 * 3.从里面读取数据 */ IntBuffer intBuffer = IntBuffer.allocate(5); //存放数据,执行该方法一次，position在底层会自动+1 intBuffer.put(10); //循环存放数据(不能超过intBuffer的容量限制),前面已经存放了2个int了，所以后面intBuffer.capacity()-2 for (int i = 0; i \u003c intBuffer.capacity() - 2; i++) { intBuffer.put(i + 12); } //如何从intBuffer中读取数据？ //读写切换(这里需要：写——\u003e读) intBuffer.flip(); /** * 常用方法如下： */ //将index的位置position设置为数组的第2位，即从第2位开始读，结果输出为11,12,13,14 intBuffer.position(1); //设置能读取到的数组数据的最大限制(不能\u003e=3个数据,即只能输出2个)，结果输出为11,12 intBuffer.limit(3); //循环读取数据: while (intBuffer.hasRemaining()){ //get()里面维护的是一个index，每get一次,索引就往右移动一次 //一个int=2bytes // 10 11 12 13 14 // ^ ^ ^ ^ ^ // ———————————————————— //| 0 | 2 | 4 | 6 | 8 | // ———————————————————— // ^ // | System.out.println(intBuffer.get()); } //get(int index) 可以读取指定索引位置处的数据 System.out.println(intBuffer.get(2)); } } ","date":"2022-06-01","objectID":"/iomodel/:0:2","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["Java基础","网络通讯"],"content":"演示NIO用FileChannel对本地文件进行IO操作-1 package com.efl.nio; import java.io.*; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; /** * Author: Azad-eng * Date: 2022/2/26 * Description: * 演示用FileChannel对本地文件进行IO操作案例1 * 1.输出.txt到本地文件目录 * 2.读取.txt文件并打印到控制台屏幕 */ public class FileChannel01 { public static void main(String[] args) throws IOException { // new FileChannel01().writeToOut(); new FileChannel01().readFromIn(); } public void writeToOut() throws IOException { /** * 思路分析： * 1.创建.txt文件的内容和在本地文件目录中的文件路径 * 2.创建一个文件输出流FileOutputStream * 3.通过FileOutputStream得到FileChannel * 4.创建缓冲区Buffer并分配容量空间 * 5.将文件写入put到缓冲区 * 6.再将缓冲区数据写入write到fileChannel中 * 7.关闭输出流 */ String srcTxt = \"hello world~\"; String dstPath = \"F:\\\\linder\\\\IoTest\\\\hello01.txt\"; FileOutputStream fileOutputStream = new FileOutputStream(dstPath); FileChannel channel = fileOutputStream.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put(srcTxt.getBytes()); byteBuffer.flip(); //将缓冲区的数据写入到file通道中(byteBuffer write to fileChannel) channel.write(byteBuffer); fileOutputStream.close(); } public void readFromIn() throws IOException { /** * 思路分析 * 1.根据目标文件地址生成文件 * 2.创建一个文件输入流,将文件数据放进去 * 3.通过FileInputStream得到FileChannel * 4.创建缓冲区Buffer并指定容量空间大小为文件的大小 * 5.再将缓冲区数据读取read到fileChannel中 * 6.打印 * 7.关闭输入流 */ String dstPath = \"F:\\\\linder\\\\IoTest\\\\hello01.txt\"; File file = new File(dstPath); FileInputStream fileInputStream = new FileInputStream(file); FileChannel channel = fileInputStream.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); channel.read(byteBuffer); byte[] array = byteBuffer.array(); System.out.println(new String(array)); fileInputStream.close(); } } ","date":"2022-06-01","objectID":"/iomodel/:0:3","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["Java基础","网络通讯"],"content":"演示NIO用FileChannel对本地文件进行IO操作-2 package com.efl.nio; import java.io.*; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; /** * Author: Azad-eng * Date: 2022/2/26 * Description:通过一个Buffer进行读写操作来完成对指定文件的拷贝 */ public class FileChannel02 { public static void main(String[] args) throws IOException { /** * 思路分析 * 1.得到copyFrom文件的文件输入流 * 2.通过文件输入流得到FileChannel * 3.创建缓冲区 * 4.循环的一边读取copyFrom的channel中的数据一边将数据写入到copyTo的channel中 * 5.关闭文件输入输出流 */ File file = new File(\"F:\\\\linder\\\\IoTest\\\\hello01.txt\"); FileInputStream fileInputStream = new FileInputStream(\"F:\\\\linder\\\\IoTest\\\\hello01.txt\"); FileChannel channelIn = fileInputStream.getChannel(); FileOutputStream fileOutputStream = new FileOutputStream(\"F:\\\\linder\\\\IoTest\\\\hello02.txt\"); FileChannel channelOut = fileOutputStream.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length()); while (true){ /** * 注意!!! * 这里要将缓冲区重置一下，否则当文件读取到最后时，position=limit=0，然后一直都是read=0，一直循环读取，始终无法读取完数据 * positon = 0; * limit = capacity; * mark = 1; */ byteBuffer.clear(); int read = channelIn.read(byteBuffer); System.out.println(read); //当read = -1 表示channelIn中的数据已经被读完了，所以要退出读写循环中 if (read==-1){ break; } //翻转byteBuffer的功能，开始将byteBuffer的数据写入到channelOut中 byteBuffer.flip(); channelOut.write(byteBuffer); } fileInputStream.close(); fileOutputStream.close(); } } ","date":"2022-06-01","objectID":"/iomodel/:0:4","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["工作总结"],"content":"在windows上安装SSH服务器 [windows自带SSH服务器：应用和功能-管理可选功能] ","date":"2022-06-01","objectID":"/ssh2/:0:1","tags":["SSH","实用工具"],"title":"如何使用 SSH 控制连接 Windows 服务器？","uri":"/ssh2/"},{"categories":["工作总结"],"content":"用管理员身份启动PowerShell自动化部署OpenSSH 服务器 确保OpenSSH 可用于安装： Get-WindowsCapability -Online | ? Name -like 'OpenSSH*' 安装： Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 初始化配置 开启 SSHD 服务： Start-Service sshd 设置服务的自启动： Set-Service -Name sshd -StartupType 'Automatic' 确认防火墙： Get-NetFirewallRule -Name *ssh* ","date":"2022-06-01","objectID":"/ssh2/:0:2","tags":["SSH","实用工具"],"title":"如何使用 SSH 控制连接 Windows 服务器？","uri":"/ssh2/"},{"categories":["工作总结"],"content":"使用nsis制作Java程序安装包的记录，nsis还可以直接把jar包生成exe可执行文件，目前使用launch4j来制作exe","date":"2022-06-01","objectID":"/nsis/","tags":["安装包脚本程序","实用工具"],"title":"NSIS安装脚本","uri":"/nsis/"},{"categories":["工作总结"],"content":"常用变量 参数脚本\r用户定义的解压路径： $INSTDIR 程序文件目录： $PROGRAMFILES 包含 NSIS 安装目录的一个标记。在编译时会检测到。常用于在你想调用一个在 NSIS 目录下的资源时，例如：图标、界面…： ${NSISDIR} 开始菜单目录： $STARTMENU 开始菜单程序目录： $SMPROGRAMS ","date":"2022-06-01","objectID":"/nsis/:0:1","tags":["安装包脚本程序","实用工具"],"title":"NSIS安装脚本","uri":"/nsis/"},{"categories":["工作总结"],"content":"安装脚本 ; 该脚本使用 HM VNISEdit 脚本编辑器向导产生 ; 安装程序初始定义常量 !define INSTDIR \"E:\\nsis\\nsis_test\" !define PRODUCT_NAME \"EFL_PotatoOSp-8601Series\" !define PRODUCT_VERSION \"1.2.7-alpha\" !define PRODUCT_PUBLISHER \"Engineering For Life\" !define PRODUCT_WEB_SITE \"http://www.efl-tech.com/\" !define PRODUCT_DIR_REGKEY \"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\${PRODUCT_NAME}.exe\" !define PRODUCT_UNINST_KEY \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" !define PRODUCT_UNINST_ROOT_KEY \"HKLM\" SetCompressor lzma ; ------ MUI 现代界面定义 (1.67 版本以上兼容) ------ !include \"MUI.nsh\" ; MUI 预定义常量 !define MUI_ABORTWARNING !define MUI_ICON \"E:\\test\\exe\\icons\\8601P.ico\" !define MUI_UNICON \"${NSISDIR}\\Contrib\\Graphics\\Icons\\modern-uninstall.ico\" ; 欢迎页面 !insertmacro MUI_PAGE_WELCOME ; 安装目录选择页面 !insertmacro MUI_PAGE_DIRECTORY ; 安装过程页面 !insertmacro MUI_PAGE_INSTFILES ; 安装完成页面 !define MUI_FINISHPAGE_RUN \"$INSTDIR\\${PRODUCT_NAME}.exe\" !insertmacro MUI_PAGE_FINISH !define MUI_FINISHPAGE_RUN_PARAMETERS \"-Dprism.order=sw\" ; 安装卸载过程页面 !insertmacro MUI_UNPAGE_INSTFILES ; 安装界面包含的语言设置 !insertmacro MUI_LANGUAGE \"SimpChinese\" ; 安装预释放文件 !insertmacro MUI_RESERVEFILE_INSTALLOPTIONS ; ------ MUI 现代界面定义结束 ------ ;引入nsh脚本-判断系统 !include \"x64.nsh\" Name \"${PRODUCT_NAME} ${PRODUCT_VERSION}\" OutFile \"${PRODUCT_NAME}_setup.exe\" InstallDirRegKey HKLM \"${PRODUCT_UNINST_KEY}\" \"UninstallString\" ShowInstDetails show ShowUnInstDetails show BrandingText \"EFL, Inc. \" Section \"Test\" Test SetOutPath \"$INSTDIR\" SectionEnd Function .onInit #安装目录设置 ${If} ${RunningX64} StrCpy $INSTDIR \"$PROGRAMFILES64\\${PRODUCT_NAME}\" ${else} StrCpy $INSTDIR \"$PROGRAMFILES\\${PRODUCT_NAME}\" ${EndIf} FunctionEnd Section \"MainSection\" SEC01 SetOverwrite ifdiff RMDir /r \"$INSTDIR\\预置模型\" RMDir /r \"$INSTDIR\\update\" RMDir /r \"$INSTDIR\\bin\\Slic3r\" RMDIR /r \"$SMPROGRAMS\\${PRODUCT_NAME}\" SetOutPath \"$INSTDIR\\bin\" File /r \"E:\\test\\exe\\bin\\*.*\" SetOutPath \"$INSTDIR\\image\" File /r \"E:\\test\\exe\\image\\*.*\" SetOutPath \"$INSTDIR\\jre\" File /r \"E:\\test\\exe\\jre\\*.*\" SetOutPath \"$INSTDIR\\libs\" File /r \"E:\\test\\exe\\libs\\*.*\" SetOutPath \"$INSTDIR\\stl\" File /r \"E:\\test\\exe\\stl\\*.*\" SetOutPath \"$INSTDIR\\update\" File /r \"E:\\test\\exe\\update\\*.*\" SetOutPath \"$INSTDIR\\预置模型\" File /r \"E:\\test\\exe\\预置模型\\*.*\" SetOutPath \"$INSTDIR\" File \"E:\\test\\exe\\${PRODUCT_NAME}.exe\" ; 创建开始菜单快捷方式 CreateDirectory \"$SMPROGRAMS\\${PRODUCT_NAME}\" CreateShortCut \"$SMPROGRAMS\\${PRODUCT_NAME}\\${PRODUCT_NAME}.lnk\" \"$INSTDIR\\${PRODUCT_NAME}.exe\" ; 创建桌面菜单快捷方式 CreateShortCut \"$DESKTOP\\${PRODUCT_NAME}.lnk\" \"$INSTDIR\\${PRODUCT_NAME}.exe\" SectionEnd Section -AdditionalIcons WriteIniStr \"$INSTDIR\\EFL官网.url\" \"InternetShortcut\" \"URL\" \"${PRODUCT_WEB_SITE}\" WriteIniStr \"$SMPROGRAMS\\${PRODUCT_NAME}\\EFL官网.url\" \"InternetShortcut\" \"URL\" \"${PRODUCT_WEB_SITE}\" SectionEnd Section -Post WriteUninstaller \"$INSTDIR\\uninst.exe\" WriteRegStr HKLM \"${PRODUCT_DIR_REGKEY}\" \"\" \"$INSTDIR\\${PRODUCT_NAME}.exe\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"DisplayName\" \"$(^Name)\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"UninstallString\" \"$INSTDIR\\uninst.exe\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"DisplayIcon\" \"$INSTDIR${PRODUCT_NAME}.exe\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"DisplayVersion\" \"${PRODUCT_VERSION}\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"URLInfoAbout\" \"${PRODUCT_WEB_SITE}\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"Publisher\" \"${PRODUCT_PUBLISHER}\" SectionEnd /****************************** * 以下是安装程序的卸载部分 * ******************************/ Section Uninstall Delete \"$INSTDIR\\EFL官网.url\" Delete \"$INSTDIR\\uninst.exe\" Delete \"$INSTDIR\\${PRODUCT_NAME}.exe\" Delete \"$SMPROGRAMS\\${PRODUCT_NAME}\\${PRODUCT_NAME}.lnk\" Delete \"$SMPROGRAMS\\${PRODUCT_NAME}\\EFL官网.url\" Delete \"$DESKTOP\\${PRODUCT_NAME}.lnk\" RMDir /r \"$INSTDIR\\预置模型\" RMDir /r \"$INSTDIR\\update\" RMDir /r \"$INSTDIR\\stl\" RMDir /r \"$INSTDIR\\jre\" RMDir /r \"$INSTDIR\\libs\" RMDir /r \"$INSTDIR\\ima","date":"2022-06-01","objectID":"/nsis/:0:2","tags":["安装包脚本程序","实用工具"],"title":"NSIS安装脚本","uri":"/nsis/"},{"categories":["工作总结"],"content":"参考链接： NSIS官网文章参考 ","date":"2022-06-01","objectID":"/nsis/:0:3","tags":["安装包脚本程序","实用工具"],"title":"NSIS安装脚本","uri":"/nsis/"},{"categories":["工作总结"],"content":"通过配置maven的pom文件来自定义打包jar","date":"2022-06-01","objectID":"/maven-pom/","tags":["pom配置","maven"],"title":"Maven-Pom","uri":"/maven-pom/"},{"categories":["工作总结"],"content":"方法一：使用 maven-jar-plugin 和 maven-dependency-plugin \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.***\u003c/groupId\u003e \u003cartifactId\u003e***\u003c/artifactId\u003e \u003cversion\u003e1.2.n\u003c/version\u003e \u003cdescription\u003e*** Printer\u003c/description\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.2.0.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c/parent\u003e \u003cproperties\u003e \u003cjava.version\u003e8\u003c/java.version\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 其他的一些dependency... --\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003c!--该插件的作用是配置mainClass，classpath--\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-jar-plugin\u003c/artifactId\u003e \u003cversion\u003e3.1.2\u003c/version\u003e \u003cconfiguration\u003e \u003carchive\u003e \u003cmanifest\u003e \u003c!--是否在manifest文件中添加classpath。默认为false。如果为true，则会在manifest文件中添加classpath--\u003e \u003caddClasspath\u003etrue\u003c/addClasspath\u003e \u003c!--classpath的前缀，比如libs/xx.jar，所有外部依赖jar包所在的文件夹名libs+jar包共同组成了类路径Class-Path--\u003e \u003cclasspathPrefix\u003elibs/\u003c/classpathPrefix\u003e \u003c!--这里改成你主类的全限定名称,mainClass = 启动时的Main Class--\u003e \u003cmainClass\u003e com.efl.javafx.desktop.ClientApplication \u003c/mainClass\u003e \u003c/manifest\u003e \u003c/archive\u003e \u003cclassifier\u003ebak\u003c/classifier\u003e \u003c/configuration\u003e \u003c!--在执行package动作的时候，自动打包--\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003ejar\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c!-- 该插件的作用是把所依赖的jar包copy到指定目录outputDirectory --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-dependency-plugin\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003ecopy-dependencies\u003c/id\u003e \u003cphase\u003eprepare-package\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ecopy-dependencies\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003c!--outputDirectory中的类路径要与maven-jar-plugin中的classpath一致--\u003e \u003coutputDirectory\u003e E:/packet/***/1-2-8/libs \u003c/outputDirectory\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c!-- 其他的一些plugin... --\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e 打包结果\r├── PotatoOSp-Client-1.2.n-bak.jar ├── libs ├── spring-boot-starter.jar\r├── 其它jar\r优点\r有诸多配置项，很自由，每个步骤都可控，然后生成的jar包是轻量级的，大小就是我们自己程序的大小\r缺点\r最终jar包中没有所依赖的jar包。依赖跟自己的代码不在一个jar包中。部署或者移动的时候，要考虑到多个文件，比较麻烦\r","date":"2022-06-01","objectID":"/maven-pom/:0:1","tags":["pom配置","maven"],"title":"Maven-Pom","uri":"/maven-pom/"},{"categories":["工作总结"],"content":"方法二：使用spring-boot-maven-plugin \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003c!-- 工程主入口--\u003e \u003cclassifier\u003espring-boot\u003c/classifier\u003e \u003cmainClass\u003e com.***.javafx.desktop.ClientApplication \u003c/mainClass\u003e \u003cincludeSystemScope\u003etrue\u003c/includeSystemScope\u003e \u003caddResources\u003efalse\u003c/addResources\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003erepackage\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 优点\r能同时打可执行jar包和war包，所有依赖都在可执行jar包中，可以方便的在任何位置都能直接运行\r缺点\r添加了一些不必要的Spring和Spring Boot依赖\r","date":"2022-06-01","objectID":"/maven-pom/:0:2","tags":["pom配置","maven"],"title":"Maven-Pom","uri":"/maven-pom/"},{"categories":["工作总结"],"content":"参考链接： Maven - 打包可执行jar包 ","date":"2022-06-01","objectID":"/maven-pom/:0:3","tags":["pom配置","maven"],"title":"Maven-Pom","uri":"/maven-pom/"},{"categories":["LeetCode"],"content":"判断字符串是否为回文串(正读反读一样的字符串，比如level,noon)","date":"2022-06-01","objectID":"/ispalindrome/","tags":["String"," LeetCode-Easy"],"title":"IsPalindrome","uri":"/ispalindrome/"},{"categories":["LeetCode"],"content":" package efl.ryl.easy; /** * Author: Azad-eng * Date: 2022/3/5 * Description: * 判断字符串是否是回文串(正读反读一样的字符串，比如level,noon) */ public class IsPalindrome { public boolean method1(String srcString) { /** * 思路分析： * 方法1——筛选+判断 * 1)遍历字符串srcString进行筛选(Character.isLetterOrDigit(srcString.charAt()))，只保留字母字符和数字字符 * 2)将筛选后的字符串的每一个字符都转换成小写(Character.toLowerCase())并放进另一个新的字符串中desString(new-\u003eappend), * 3)判断desString是否为回文串： * -使用翻转字符串的方法reverse得到把desString倒序读的字符串revString(注意这里要生成一个新的倒置的字符串，不能直接改变desString) * -将revString与desString进行相等判断,如果相等返回true，表示是回文串，反之false */ StringBuffer desString = new StringBuffer(); for (int i = 0; i \u003c srcString.length(); i++) { if (Character.isLetterOrDigit(srcString.charAt(i))) { desString.append(Character.toLowerCase(srcString.charAt(i))); } } // StringBuffer reverse = desString.reverse(); x // desString是StringBuffer类的,保存的是字符串变量,不同于String,里面的值是可以更改的。为了避免这种更改,所以要新建一个StringBuffer StringBuffer revString = new StringBuffer(desString).reverse(); // return revString.equals(desString); x // 这里的revString和desString是两个object，这里equals判断的是两个对象是否是同一个对象，而不是判断它们的值是否相等 return (new String(revString)).equals(new String(desString)); } public boolean method2(String srcString) { /** * 思路分析 * 方法2——双指针 * 1)引入两个index变量int left=0 , int right = srcString.length()-1 * 2)+————————————————————+ * | | | | | | | | * +————————————————————+ * ^ ^ * | | * left right * 3)让left向右移动，right向左移动，一直循环到left\u003eright,如果期间遇到非数字或字母的字符就让left++,或right--，即跳过它们 * 4)对全部转成成小写的字符做出相等判断，一旦有一组字符不等，就返回false，如果循环结束依然没有返回false，代表该字符串是回文串，那么返回true */ int left = 0; int right = srcString.length() - 1; while (left \u003c= right){ if(Character.toLowerCase(srcString.charAt(left))!=Character.toLowerCase(srcString.charAt(right))){ return false; } left++; right--; if (!Character.isLetterOrDigit(srcString.charAt(left))){ left++; } if (!Character.isLetterOrDigit(srcString.charAt(right))){ right--; } } return true; } public static void main(String[] args) { System.out.println(new IsPalindrome().method2(\"l,ev e l\")); } } ","date":"2022-06-01","objectID":"/ispalindrome/:0:0","tags":["String"," LeetCode-Easy"],"title":"IsPalindrome","uri":"/ispalindrome/"},{"categories":["LeetCode"],"content":"二维列表的运用——杨辉三角","date":"2022-06-01","objectID":"/pascaltriangle/","tags":["二维列表"," LeetCode-Easy","ArrayList"],"title":"PascalTriangle","uri":"/pascaltriangle/"},{"categories":["LeetCode"],"content":" package efl.ryl.easy; import java.util.ArrayList; import java.util.List; /** * Author: Azad-eng * Date: 2022/3/3 * Description: 杨辉三角 */ public class Pascal_Triangle { // [1] // [1,1] // [1,2,1] // [1,3,3,1] // [1,4,6,4,1] // [............] public List\u003cList\u003cInteger\u003e\u003e generate(int numRows) { //二维列表的运用——杨辉三角 /** * 思路分析： * 1.主集合List\u003cList\u003cInteger\u003e\u003e ret有且仅有一个，但子集合List\u003cInteger\u003e row 有numRows个(numRows=ret.size()),因此要new创建ret.size()个row * -所以 for (int i = 0; i \u003c numRows; ++i) {} * 2.row集合中元素的add规律：第1行，add 1次，第2行，add 2次...第numRows行，add numRows次 * -所以 for (int j = 0; j \u003c= i; ++j){} * 3.add的值也有规律： * -3.1 每一行头尾(第一个行头尾重合)的值都是1：row.get(0)=1，row.get(i)=1 * -所以if (j == 0 || j == i) {row.add(1);} * -3.2 非头尾的值 =上一行的相同位置的前一个元素的值 +上一行的相同位置的元素的值 * -所以 row.add(ret.get(i-1).get(j-1) + ret.get(i-1).get(j)) */ //List是接口，不能实例化,因此List\u003cList\u003cInteger\u003e\u003e list = new List\u003c\u003e(); x List\u003cList\u003cInteger\u003e\u003e ret = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c= numRows - 1; i++) { List\u003cInteger\u003e row = new ArrayList\u003c\u003e(); for (int j = 0; j \u003c= i; j++) { if (j == 0 || j == i) { row.add(1); } else { row.add(ret.get(i - 1).get(j - 1) + ret.get(i - 1).get(j)); } } ret.add(row); } return ret; } public static void main(String[] args) { System.out.println(new Pascal_Triangle().generate(5)); } } ","date":"2022-06-01","objectID":"/pascaltriangle/:0:0","tags":["二维列表"," LeetCode-Easy","ArrayList"],"title":"PascalTriangle","uri":"/pascaltriangle/"},{"categories":["LeetCode"],"content":"返回和为目标值的两数的下标数组","date":"2022-06-01","objectID":"/twosums/","tags":["哈希查找"," LeetCode-Easy","数组","int[]"],"title":"TwoSums","uri":"/twosums/"},{"categories":["LeetCode"],"content":" package efl.ryl.easy; import java.util.*; /** * Author: Azad-eng * Date: 2022/3/5 * Description: 返回和为目标值的两数的下标数组 */ public class TwoSums { public int[] method1(int[] nums, int target) { /** * 暴力解法——线性查找(完整的遍历一次数组的时间复杂度为——O[n]) * 当i=0时，j={1,2...nums.length-1}即需要将i与j比较n-1次 * 当i=1时，j={2,3...nums.length-1}即需要将i与j比较n-2次 * ...... * 当i=n-1时，j={nums.length-1}即需要将i与j比较1次 * 一共比较了(n-1)+(n-2)+(n-3)+...1次 * 等差序列求和：n*(n-1)/2 = 1/2 n^2 - 1/2n * 因此时间复杂度=O(n^2) */ int[] ints = new int[2]; for (int i = 0; i \u003c nums.length; i++) { for (int j = 0; j \u003c nums.length; j++) { if (i != j \u0026\u0026 (nums[j] == target - nums[i])) { ints[0] = j; ints[1] = i; break; } } } return ints; } public int[] method2(int[] nums, int target) { /** * 优化——哈希查找 * 时间复杂度=O(n) * [优势只有在数据量大时才能凸显] */ if (nums == null || nums.length == 0) { return new int[0]; } HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); Set\u003cInteger\u003e keySet = map.keySet(); for (int i = 0; i \u003c nums.length; i++) { map.put(i, nums[i]); if (map.containsValue(target - nums[i])) { for (Integer key : keySet) { if (map.get(key).equals(target - nums[i]) \u0026\u0026 key != i) { return new int[]{key, i}; } } } } return new int[0]; } public static void main(String[] args) { System.out.println(Arrays.toString(new TwoSums().method2(new int[]{3, 2, 4}, 6))); } } ","date":"2022-06-01","objectID":"/twosums/:0:0","tags":["哈希查找"," LeetCode-Easy","数组","int[]"],"title":"TwoSums","uri":"/twosums/"},{"categories":["Java基础","知识汇总"],"content":"流程控制图｛顺序｝｛分支｝｛循环｝｛break｝{continue}","date":"2022-05-31","objectID":"/controlflow/","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":["Java基础","知识汇总"],"content":"顺序控制 程序从上到下逐行执行，中间没有任何判断和跳转 ","date":"2022-05-31","objectID":"/controlflow/:0:1","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":["Java基础","知识汇总"],"content":"分支控制 让程序有选择的执行 分支控制 (if)\r分支控制 (switch)\r","date":"2022-05-31","objectID":"/controlflow/:0:2","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":["Java基础","知识汇总"],"content":"循环控制 满足条件则程序循环执行，通过变量迭代，等到条件无法满足时就退出循环。因此引入合适的迭代的变量可以有效的规避死循环 循环控制\r","date":"2022-05-31","objectID":"/controlflow/:0:3","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":["Java基础","知识汇总"],"content":"循环跳转控制 break[用于终止某个语句块的执行，一般用于switch分支控制或者循环控制程序中] 循跳转环控制 (break)\rcontinue[用于结束本次循环，继续执行下一次循环] 注意\r注意不同于break，continue语句执行前一定要有迭代变量操作，否则就会陷入死循环 for循环比较特殊，虽然for循环内的迭代变量的执行顺序的确在循环体操作之后，但是它不在循环体内，所以continue没有跳过它，执行完continue语句后，会接着执行迭代变量操作，再执行条件判断 循跳转环控制 (continue)\rreturn[表示让程序跳出当前所在的方法，然后继续执行] ","date":"2022-05-31","objectID":"/controlflow/:0:4","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":null,"content":"\r","date":"2022-05-25","objectID":"/friends/:0:0","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"JAVA Java 全栈知识体系\r\"包含: Java 基础, Java 部分源码, JVM, Spring, Spring Boot, Spring Cloud, 数据库原理, MySQL, ElasticSearch, MongoDB, Docker, k8s, CI\u0026CD, Linux, DevOps, 分布式, 中间件, 开发工具, Git, IDE, 源码阅读，读书笔记, 开源项目...\"\r代码随想录\r\"本站是一套完整的刷题计划，旨在帮助大家少走弯路，循序渐进学算法\"\rJava 程序员进阶之路\r\"沉默王二的专属知识星球\"\r程序员自由之路\r\"\"\r风祈的时光录\r\"主要是Java技术栈的文章，涉及到了源码、原理的知识\"\r_跑调大叔_\r\"天下事有难易乎 \u003e 为之，则难者亦易 \u003e 不为，则易者亦难\"\r","date":"2022-05-25","objectID":"/friends/:0:1","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"大佬专用 雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r慕雪的寒舍\r\"吾心如一，慕雪纷纷\"\rCqh-i\r\"你的问题,主要在于读书不多而想得太多\"\rSukun的博客\r\"Sukun的博客，记录学习历程！\"\rBarney’s Blog\r\"All the truth is simple\"\r低调小熊猫\r\"读万卷书，行万里路，赚很多钱\"\r","date":"2022-05-25","objectID":"/friends/:0:2","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"3D打印 概念清楚吧\r\"写点平时科研的时候会关注的问题\"\r","date":"2022-05-25","objectID":"/friends/:0:3","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"BLOG 阮一峰的网络日志\r\"这里记录每周值得分享的科技内容，周五发布。\"\r巴托什切哈诺夫斯基\r\"知识型博客\"\r","date":"2022-05-25","objectID":"/friends/:0:4","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"官方 dillonzq/LoveIt\r\"Hugo-LoveIt主题github\"\rLoveIt官方文档\r\"Hugo-LoveIt主题官方文档\"\r","date":"2022-05-25","objectID":"/friends/:0:5","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"\r","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"\r","date":"0001-01-01","objectID":"/treasure/:0:0","tags":null,"title":"🧰宝藏收藏匣","uri":"/treasure/"},{"categories":null,"content":"学习圣地~📝📚📖🏛 CS 61A \"计算机程序构造和解释网络课程（python）\"\rSICP Interactive Book \"计算机程序构造和解释在线阅读（交互式）\"\r","date":"0001-01-01","objectID":"/treasure/:0:1","tags":null,"title":"🧰宝藏收藏匣","uri":"/treasure/"},{"categories":null,"content":"实用的工具~🔨✒📐 Fontawesome Icon\r\"为项目找到最适合的图标\"\rSVG Editor\r\"SvgPath编辑器\"\rRegexr\r\"学习、构建和测试正则表达式\"\r","date":"0001-01-01","objectID":"/treasure/:0:2","tags":null,"title":"🧰宝藏收藏匣","uri":"/treasure/"},{"categories":null,"content":"API文档速查~🔎 Java\r\"Java™ Platform, Standard Edition 8 API\"\rJavaFx\r\"JavaFX 8 API\"\rJSSC\r\"JSSC API\"\r","date":"0001-01-01","objectID":"/treasure/:0:3","tags":null,"title":"🧰宝藏收藏匣","uri":"/treasure/"}]