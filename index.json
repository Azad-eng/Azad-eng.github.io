[{"categories":["生活"],"content":"有目的的练习及更规律地训练：每周尝试和练习至少 2-3 次，自己或与伙伴一起练习，并在心中有一个明确的目标的情况下练习特定的技能。","date":"2023-05-11","objectID":"/badminton/","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"前言 前言\r科学的练习羽毛球非常重要\r","date":"2023-05-11","objectID":"/badminton/:0:1","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"一、始终正确预热及冷却 为什么要热身和冷却？\r肌肉是有弹性的，它们会放松和收缩以推动和拉动以允许运动。就像松紧带一样，当我们的肌肉因静止太久而变冷时，它们会变得僵硬， 因此不容易伸展以允许运动。我们需要慢慢地让它们暖和起来，直到它们能够轻松地伸展和收缩。你更有可能因缺乏高质量的热身而受伤。 拉伸时寒冷的肌肉更容易因过于僵硬而撕裂和撕裂。 大多数人会继续进行快速“热身”，作为让自己热身准备比赛的一种方式。问题是他们一开始就互相打球，这需要上半身进行相当有爆发力的运动， 这不是一个渐进的热身，也无助于伸展身体的所有肌肉群为比赛做好准备。 当你玩完游戏后最好进行冷却，就像热身一样，这是大多数人很少做但应该做的事情。执行 5-10 分钟的降温程序有助于让您的身体逐渐恢复到自然休息点。 它会逐渐降低您的心率和呼吸频率，降低您的体温，让您的肌肉恢复到自然的静息张力和长度，并有助于防止接下来几天的肌肉酸痛并提高肌肉的柔韧性。\r我们的第一个羽毛球技巧是确保正确热身对任何运动都非常重要。你需要让你的肌肉舒适温暖，这样它们才能轻松伸展。这将有助于避免不必要的伤害， 并让您为快节奏的羽毛球运动做好准备。 那么如何正确热身和冷却呢？ 简单的答案是：需要做一个使用动态伸展的全身热身运动，可能需要大约5-10分钟，然后使用静态伸展运动进行全身放松，持续时间大致相同。 运动前的热身 热身的套路和方法数不胜数，但它们的共同点是都涉及动态拉伸。动态拉伸是在运动时加热和拉伸您的肌肉，而不是站在原地，动态拉伸的例子包括各种 弓箭步、摆腿、下蹲、跳跃等。像hanging the bird这样的视频是教练帮助初学者的有用工具， “动态热身”程序对每个人来说都是至关重要的。这样我们就可以拉伸肌肉放松，运动会让我们的心脏跳动并开始让我们暖和起来，而静态拉伸只会拉伸肌肉，但不会让你的身体热身。 以下是一些典型的热身动作，它是一种很好的快速热身，可以锻炼所有主要肌肉群，尤其适合打羽毛球： 动态热身程序\r50个开合跳 10次扭转弓步（每条腿5次） 20次手和膝盖手臂伸展 5个哈拉萨纳斯 50个高膝盖 10次深蹲跳\r开合跳 扭转弓步 运动后的放松和拉伸 与比赛前正确热身一样重要的是比赛后的放松和伸展运动。作为初学者，确保慢慢冷静下来并随后伸展肌肉非常重要。 良好的降温会慢慢降低你的体温，这意味着你的肌肉不会僵硬和变冷太快。事后趁热伸展肌肉有助于提高柔韧性并减少导致肌肉僵硬和抽筋的乳酸堆积。 降温的目的是逐渐减慢身体的进程，而不是突然停止然后大口喘气。降温时，我们会结合步行或慢跑等低强度活动和静态拉伸来减轻训练后几天经常感到 的酸痛和僵硬。 非常适合羽毛球后训练的典型冷却时间如下所示： 静态冷却程序\r稳定、轻松地慢跳 3-5 分钟 婴儿式，30 秒 蝴蝶伸展，30 秒 腘绳肌拉伸，每条腿30秒 臀部伸展，每条腿30秒 站立前屈，30秒 股四头肌拉伸，每条腿30秒 小腿伸展，每条腿30秒 肩部伸展，每只手臂30秒 胸部伸展，每侧30秒\r这将足以锻炼身体的所有部位，对于羽毛球运动来说，下半身尤为重要，所有的弓步和扭转动作都需要臀部和腿部具有良好的柔韧性。 ","date":"2023-05-11","objectID":"/badminton/:0:2","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"二、学会握拍和基础发球 如何握羽毛球拍——正确的羽毛球握拍 如何改进羽毛球短发球（7 个步骤） ","date":"2023-05-11","objectID":"/badminton/:0:3","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"三、学习一些基础击球、接球和步法 初学者羽毛球练习 - 掌握基础知识的 11 个练习 良好的步法就像了解一种语言的字母表 可以通过观看高级玩家的视频来学习，比如下面的林丹完美的步法： ","date":"2023-05-11","objectID":"/badminton/:0:4","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"四、建立一些良好的打球习惯 专注于保持平衡 保持你的球拍 这个技巧说起来容易做起来难。自然地，当人们不活动时，他们希望将手臂放在两侧。很多时候你都想克制这样做的冲动，尤其是当你在网前打双打时。 当我说让你的球拍也保持向上时，我并不是说在你的头顶上方，我只是指向上和向外指向，以便更快地做好准备。每次都必须从你的身边举起你的球拍 很慢，所以保持你的球拍向上。我们提到了双打比赛，看看这个Kevin Sanjaya Sukamuljo的比赛视频。他总是准备好球拍。如果他离网很近， 他的球拍可能会更高以进行拦截。 打的时候放松 大多数人认为羽毛球的力量来自于肌肉和力量。他们看到顶级球员在比赛中表现出如此的侵略性，看起来他们正在施加如此大的力量。初学者养成了 过度紧张、过度努力的习惯。 你的肌肉需要放松才能自由移动，如果你在击球前紧紧抓住你的球拍并紧张起来，你就不能产生很大的球拍速度。你不是想在这里举重，你是想通过运动 产生力量。击球时保持放松，让球拍和挥杆做更多的工作。 恢复回到中心 羽毛球是关于你的敏捷性。你应该学习了解如何在球场上“移动”而不是奔跑。它将使您更快并节省大量能量。你不能跑到球场的每个角落，因为那样你会失去平衡。相反，你应该伸展身体来选择一个 穿梭，然后回到你的中心位置。有许多 Yoututbe 视频演示了如何正确移动。 比如，来自Coaching Badminton的Lee Jae Bok有一段很棒的视频，其中谈到了击球后的恢复： 加强手腕 提高比赛水平的最重要方法是加强手腕。你的反手、正手、扣球、吊球都需要一个强壮而灵活的手腕。所以尽可能多地使用你的手腕。 例如，当你想打反手时，不要挥动你的整个手臂，而是尽量用你的手腕。有多种练习程序可以改善您的手腕。 有策略地玩球： 你不需要想出宏大的计划，但玩的时候要聪明。你应该根据自己的优势发挥，同时，你应该牢记对手的优势和劣势。如果对方的正手防守好，反手不好， 那他的正手杀球就没有意义了。这是你需要聪明的地方。 将球打到对手必须跑动的地方/很难还击 双打羽毛球制胜秘诀（策略、战术和技巧） ","date":"2023-05-11","objectID":"/badminton/:0:5","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"五、掌握一些练习提升方法 墙练习 Here are Badminton drills you can do at home: Ladder drills\rFast feet exercises\rSix shuttles shuttle run\rSix corners footwork shadowing\rExplosive split-step drill\rThe wall drill\rChanging grip\rFinger and forearm power\rRound the clock defensive shadow\rOverhead stroke practice\rShuttle juggling\r在家练习（中文版）: 阶梯钻\r快速足部练习\r六班车穿梭跑\r六角步法阴影\r爆破分步钻\r墙钻\r改变抓地力\r手指和前臂力量\r全天候防御阴影\r过顶划水练习\r穿梭杂耍\r建立反馈 ","date":"2023-05-11","objectID":"/badminton/:0:6","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"六、观看一些优质的教学视频 学习羽毛球的最佳Youtube频道如下： Tobias Wadenka 托拜厄斯是一名一半是球员，一半是教练。前德国国脚，擅长男单。他的 YouTube 频道擅长通过分解羽毛球的基础知识来创建适合初学者的教育内容。 他的内容清晰准确，并提供了很好的实践技术示例。在最近的内容中，他开始涉足练习和对羽毛球运动员比赛日的有趣见解。 推荐用于： 初学者羽毛球运动员起。Tobias 很好地涵盖了羽毛球的基础知识，他深入探讨了每个主题。由于技术和执行背后的战术解释，初学者将受益最大。 羽毛球教练 李在福的频道“羽毛球教练”。李在福是前韩国单打、双打和混双全国冠军。他是一位拥有 50 年打羽毛球和执教经验的教练。 他曾在 1980 年代和 90 年代担任过韩国、英国和英国奥林匹克运动队的主教练，多年来一直在九个不同的国际教练会议上发表演讲。 作为 YouTube 上最早的羽毛球频道之一，Lee 自 2010 年以来一直在 YouTube 上发布羽毛球教育内容！在那段时间里，他发布了 800 多个视频， 涵盖从步法到双打定位的所有内容。 推荐用于： 各个级别的羽毛球运动员。从以前从未玩过并想掌握基础知识的高级玩家到想学习更高级策略的高级玩家，Lee 的频道应有尽有。 教练员。Lee 的很多内容都让玩家练习特定的训练来提高一些非常具体的东西。教练可以将这些练习带走，以便在执教球员时使用。 Prit Pachu Prit 拥有超过 25 年的羽毛球教练经验，有很多智慧和知识可以在 YouTube 上与观众分享。一名英国羽毛球协会的 3 级 UKCC 羽毛球教练与一名 理学硕士并肩作战。运动生理学与环境医学和 BKin。Exercise \u0026 Sports Science 可以说他是合格的。 Prit 的视频非常详细，他使用他所有的运动科学知识来说明击球动作和步法模式是如何工作的。我们很高兴看到他将在未来为 YouTube 带来哪些新内容。 推荐用于： 初级玩家。截至 2020 年，Prit 一直在重新提交他录制的带有画外音和更高质量视频的 YouTube 视频。他的内容目录很小，但非常详细地涵盖了初学者的内容。 BG Badminton Academy Gerald Ong 是 YouTube 上 BG Badminton Academy 的创建者。他曾是新加坡国际羽毛球运动员，现担任羽毛球教练。杰拉尔德很容易成为这个频道 如此特别的原因。 他对羽毛球和教学有着真正的热情。他在整个视频中的能量总是鼓舞人心，他在观看时总是让我脸上露出微笑。羽毛球不应该只是提高，还应该有乐趣。 杰拉尔德指出了这一点。 推荐用于： 有一定经验的羽毛球运动员。Gerald 提供了一些很棒的内容，但我建议绝对初学者查看其他频道以获得涵盖基础知识的更深入的视频。他的内容最适合 那些已经具备一定能力的人。 TAGO KEN 绝对是教育版块最独特的频道。TAGO KEN 是日本前选手 Kenichi Tago 的 YouTube 频道。自从他离开比赛后，他将自己定位为一名独立教练。他的 频道既有教育教程，也有记录他的旅行和指导的一般视频博客类型的内容。 他最早的内容对步法和球拍技巧有一些详细的见解。他的内容全部是日语，没有专门的字幕，这意味着除非你懂日语，否则很难理解。YouTube 的 自动字幕做得不错，但我认为有些东西在翻译中丢失了。 推荐用于： 羽毛球爱好者。他的内容中有很多来自他那个时代世界上最好的球员之一的智慧金块。他的大部分内容都是日语，没有专门的字幕，所以我无法判断 他的内容最适合哪个级别的学习者。话虽如此，每个人都可以从前世界第三那里学到一些东西。 Swift Badminton 来自英国的 Jonathan 在 YouTube 上创立了 Swift Badminton，他不是普通的草根羽毛球运动员。就像所有拿起球拍的人一样，他立即爱上了 这项运动，但在没有正式教练的情况下，他开始在没有教练的情况下提高水平。 在撰写本文时，他的订阅者超过 7 万，但仅发布了 25 个视频，事实证明他的内容非常受欢迎。他混合了教育和娱乐内容。 他的教育内容往往只涵盖一个方面，但他涵盖了很多深度。他的低反手发球视频非常好。 不过，他最有趣的内容是他的娱乐视频。像羽毛球教练的类型和打羽毛球的 7 种方法这样的视频是您在其他任何地方都看不到的视频。 推荐用于： 狂热的羽毛球运动员。Swift Badminton绝对是铁杆羽毛球爱好者的频道。乔纳森获得了他的观众，并且知道如何为他们创造内容。然而，最近的视频 已经远离了教育内容。 Shuttle Life Mads 和 Sophie 是丹麦的专业羽毛球教练。他们开设 YouTube 频道是为了帮助教练和球员进行日常训练。在撰写本文时，他们拥有超过 300 个视频和近 20 万订阅者，他们无疑实现了这一目标。 Shuttle Life 的内容因其标志性的视频风格而在教授人们羽毛球方面非常有效。他们在录制的镜头之上使用大量注释来说明要注意的关键事项， 并使用多个摄像机角度来提供完整的画面。 虽然他们的大部分内容都是信息性的，但他们确实涉足了制作有趣的技巧视频、合作和打破棘手的印尼旋转发球。 推荐用于： 羽毛球运动员，任何级别。它们主要涵盖适合已经具备羽毛球基础知识的球员的领域。然而，他们制作了一个由三部分组成的精彩系列视频， 将他们以前的内容整理成三个易于理解的视频。 羽毛球爱好者。如果你只是想看特技镜头，那么他们有一些很棒的视频可以展示这一点。 羽毛球番剧： 《轻羽飞扬》 观看高级玩家 可以学习任何书籍或教练都不会告诉您的策略、技术和战术。 ","date":"2023-05-11","objectID":"/badminton/:0:7","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"七、保存良好的心态 不要试图做到完美 许多初学者在学习新事物时犯了一个错误，即他们必须使每个方面都完美无缺。不要太专注于让一切都绝对正确，而是专注于取得进步。 如果您正在学习一个新镜头，请专注于学习该技术的各个部分，但要花同样多的时间将它们整合在一起。很可能您不会掌握所有方面，这很好。 专注于渐进式改进，随着时间的推移，这些改进会累积成很大的改进。完美本身是无法实现的，有史以来最伟大的球员从未达到完美。接受你会犯错误， 你会发现有些事情比其他事情更难掌握。只要您专注于微小的改进，就会产生不同。 以积极的心态玩耍 说起来容易做起来难，但很多时候球员在上场之前就击败了自己。如果你知道你要对抗一个更强大的玩家，不要想“哦，天哪，我现在要被踩死了”， 而是把它当作一个学习的机会。在这种情况下，你没有什么可失去的，一切都会得到，其他玩家有望获胜，去那里自由发挥。 对某些人来说，积极思考可能很难。站起来坚守阵地并不容易。你需要在球场内外培养积极的心态。Martin Hagger 在 TEDxPerth 做了一次演讲， 他深入探讨了冠军运动员的心态，强烈推荐观看。 ","date":"2023-05-11","objectID":"/badminton/:0:8","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"八、了解规则 ","date":"2023-05-11","objectID":"/badminton/:0:9","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["生活"],"content":"参考链接 13 Essential Badminton Tips for Beginners (To Improve Fast) The Best Badminton YouTube Channels You Should Be Watching How to Warm-Up and Cooldown Properly to Avoid Injury? Badminton Drills at Home [Improve with Practical, Effective Exercises] ","date":"2023-05-11","objectID":"/badminton/:0:10","tags":["羽毛球","运动"],"title":"羽毛球初学者指南","uri":"/badminton/"},{"categories":["工作总结"],"content":"Maven简介 是一个软件项目管理及自动构建工具，主要解决了软件构建的两方面问题：一是软件是如何构建的，二是软件的依赖关系 ","date":"2023-05-10","objectID":"/maven/:0:1","tags":["maven"],"title":"Maven","uri":"/maven/"},{"categories":["工作总结"],"content":"Maven工具的安装和配置 1.官网下载Maven: 选择Binary zip archive 2.配置环境变量： 添加系统变量（变量名：M2_HOME，变量值：maven安装目录D:\\software\\apache-maven-3.8.4），然后将变量名添加到path里（% M2_HOME %\\bin 3.验证是否安装成功 mvn –v ","date":"2023-05-10","objectID":"/maven/:0:2","tags":["maven"],"title":"Maven","uri":"/maven/"},{"categories":["工作总结"],"content":"在IDEA中配置Maven 为什么IDEA中有内置的Maven，还有自己配置？\r因为内置的maven修改settings.xml文件不方便，比如修改本机仓库地址不便等...所以需要使用自己安装的maven来覆盖IDEA中默认的配置，即在IDEA中指定maven的安装位置等信息\r1.IDEA配置Maven的具体位置: 2.IDEA配置Maven运行环境的具体位置: 3.创建Maven项目: 4.创建Maven项目能的报错及解决方案: 5.Pom(project-object-module)项目对象模型: 6.项目(生命周期)的构建: ","date":"2023-05-10","objectID":"/maven/:0:3","tags":["maven"],"title":"Maven","uri":"/maven/"},{"categories":["工具"],"content":"BLOG相关 1. 打开本地博客 $ hugo server -e production --disableFastRender --port=1515 -D 2. 更新博客网站内容流程 step1- 关闭本地博客 step2- 博客项目下打开bash $ hugo $ cd public 【将public下生成的静态文件全都提交并同步到github上的网站项目中】 $ git init (如果已是git项目则忽略该步骤） $ git status $ git add . $ git commit -a -m \"xxxx\" $ git push -u origin master --force step3- 确认github项目是否更新 step4- 用ping命令找到存放github pages的主机的IP地址，比如[185.199.111.153]。在CMD终端里面用命令ping azad-eng.github.io便可完成 step5- 进入域名管理网站，确保记录值IP地址和上面的保持一致 step6- 填写【项目-Settings-Pages-site中】的自定义域azad-eng.space并保存，然后检查网站地址是否更新 step7- 点击Visit site 3. LoveIt主题admonition样式代码 4. 注意事项 项目bin目录地址更改以后，环境变量里的hugo/bin地址也要相应改动 5.文章属性配置 //标题 title: \"\" //副标题 subTitle: \"\" //主页显示描述，与\u003c!- -more- -\u003e 搭配使用，如果没有该属性，主页显示正文开头 description: \"\" //文章是否出现在主页 hiddenFromHomePage: true //文章链接地址 url: /ZenMotor/ tags: [ \"标签0\", \"标签1\", \"...\" ] categories: - \"分类0\" - \"分类1\" - ... //创建日期 date: 2022-02-22 //更新日期 lastmod: 2022-2-22 //是否打开评论 comment: false //是否为草稿，是则部署时会不显示文章 draft: true ","date":"2023-05-10","objectID":"/hugo/:0:1","tags":["hugo"],"title":"hugo建站笔记","uri":"/hugo/"},{"categories":["阅读记录"],"content":"书签 📝 ？\r。\r","date":"2023-02-27","objectID":"/Christophe/:0:1","tags":["阅读记录"],"title":"《约翰·克利斯朵夫》","uri":"/Christophe/"},{"categories":["阅读记录"],"content":"书签 📝 哪一个才是真正的科学实验？\r一个人操作着价值五万美金的福兰克斯坦仪器进行科学实验，如果他事先就知道了结果，那么整件事就毫无科学可言。然而修理摩托车的人如果为了检查电池是否仍然有电 而按喇叭，却是一种真正的实验，因为他是用实际行动去证实他的假设。\r休谟的经验主义论\r休谟认为，一个人如果能遵循经验中最严格的归纳和演绎的思维，就能够认识世界的本质。他的这种看法被归纳为经验主义，也就是相信所有的认知来自于人的感官。 经验主义的第一个问题和本体的性质有关。如果我们所有的知识都来自于感官，那么给与这些感官知识的本体是什么？ 经验主义的第二个问题是，如果一个人假设我们所有的认知都来自于感官，那么哪一个感官接收了因果关系的认知？(P177)\r对事物抱有强信心会导致狂热态度的产生吗？\r如果你对事情有完全的信心，就不太可能产生狂热的态度。就拿太阳来说吧，没有人会为了它明天会升起而兴奋不已，因为这是必然的现象。\r","date":"2023-02-26","objectID":"/ZenMotor/:0:1","tags":["阅读记录"],"title":"《禅与摩托车维修艺术》","uri":"/ZenMotor/"},{"categories":["工具"],"content":"Github配置ssh免密登录 step1 生成密钥对 $ ssh-keygen -t rsa -C \"test@email.com\" step2 检查电脑系统用户目录下是否出现.ssh文件夹（ls: id_rsa,id_rsa.pub step3 登录 github 打开个人中心 点击 Settings-SSH and GPG keys-New SSHkey，填写标题（比如：设备名+ssh -\u003e sv7-ssh)， 将id_rsa.pub文件的全部内容粘贴进去 ","date":"2023-02-26","objectID":"/git/:0:1","tags":["git\u0026github"],"title":"git\u0026github","uri":"/git/"},{"categories":["工具"],"content":"Git疑难杂症 1.fetch-pack: unexpected disconnect while reading sideband packet early EOF unpack-objects failed -\u003e git bash运行 git config --global pack.windowsMemory 256m 2.kex_exchange_identification: Connection closed by remote host Could not read from remote repository. -\u003e 确保没有连接任何VPN ","date":"2023-02-26","objectID":"/git/:0:2","tags":["git\u0026github"],"title":"git\u0026github","uri":"/git/"},{"categories":["工具"],"content":"在IDEA上集成Git ","date":"2023-02-26","objectID":"/git/:0:3","tags":["git\u0026github"],"title":"git\u0026github","uri":"/git/"},{"categories":["工具"],"content":"团队协作\u0026跨团队协作 ","date":"2023-02-26","objectID":"/git/:0:4","tags":["git\u0026github"],"title":"git\u0026github","uri":"/git/"},{"categories":null,"content":"\r","date":"2023-02-26","objectID":"/reading/:0:0","tags":null,"title":"阅读记录之旅","uri":"/reading/"},{"categories":null,"content":"形而上学类~ 禅与摩托车维修艺术\r\"❤❤❤Zen and the Art of Motorcycle Maintenance\"\r","date":"2023-02-26","objectID":"/reading/:0:1","tags":null,"title":"阅读记录之旅","uri":"/reading/"},{"categories":null,"content":"理想主义之书~ 约翰·克利斯朵夫\r\"❤❤❤Jean-Christophe\"\r","date":"2023-02-26","objectID":"/reading/:0:2","tags":null,"title":"阅读记录之旅","uri":"/reading/"},{"categories":null,"content":"其他~ 英语魔法师之语法俱乐部\r\"❤❤❤旋元佑\"\r","date":"2023-02-26","objectID":"/reading/:0:3","tags":null,"title":"阅读记录之旅","uri":"/reading/"},{"categories":["工具"],"content":"Regex正则表达式 组成 （1）字符类 1.字符集：[ABC] 匹配集合中的任何一个字符 例子：[aeiou] 匹配：glib jocks vex dwarves! 2.否定集[^ABC] 匹配不在集合中的任何一个字符 例子：[^aeiou] 匹配：glib jocks vex dwarves! 3.范围[A-Z] 匹配（含）两个指定字符之间的任意字符 例子：[g-s] 匹配：abcdefghijklmnopqrstuvwxyz 4.点. 匹配除换行符之外的任何一个字符 相当于[^\\n\\r] 例子：.匹配：glib jocks vex dwarves! 5.匹配任何[\\s\\S] 一个字符集，可用于匹配任何一个字符，包括换行符 例子：[\\s\\S]匹配：glib jocks vex dwarves! 6.单词\\w 匹配任何一个单词字符（字母数字和下划线） 仅匹配低位 ASCII 字符（无重音字符或非罗马字符），相当于[A-Za-z0-9_] 例子：\\w匹配：bonjour,mon frère 7.非单词\\W 匹配任何一个非单词字符（字母数字和下划线） 相当于[^A-Za-z0-9_] 例子：\\W匹配：bonjour,monNULLfrère 8.数字\\d 匹配任何一个数字字符 (0-9) 相当于[0-9] 例子：\\d匹配：+1-(444)-555-1234 9.非数字\\D 匹配任何一个非数字字符 (0-9) 相当于[^0-9] 例子：\\D匹配：+1-(444)-555-1234 10.空格\\s 匹配任何一个空白字符（空格、制表符、换行符） 相当于[^0-9] 例子：\\s匹配：glibNULLjocksNULLvexNULLdwarves! 11.非空格\\S 匹配任何一个非空白字符（空格、制表符、换行符） 相当于[^0-9] 例子：\\S匹配：glib jocks vex dwarves! （2）量词和交替 1.加号：+匹配 1 个或多个前面的标记 例子：b\\w+ 匹配：b be bee beer beers 2.星号：*匹配 0 个或多个前面的标记 例子：b\\w* 匹配：b be bee beer beers 3.量词：{1,3}匹配指定数量的的标记 {1,3}将匹配 1 到 3，{3}将完全匹配 3，{3,}将匹配 3 个或更多 例子：b\\w{2,3}* 匹配：b be bee beer beers 4.optional：？匹配前面标记的 0 或 1 个，有效地使其成为可选的 例子：colou?r* 匹配：color colour 5.lazy：？使前面的量词惰性化，使其匹配尽可能少的字符 默认情况下，量词是贪婪的，会匹配尽可能多的字符 例子：b\\w+?* 匹配：b be bee beer beers 6.交替：|类似于布尔 OR。匹配之前或之后的表达式 它可以在一个组内运行，也可以在整个表达式上运行 例子：b(a|e|i)d 匹配：bad bud bod bed bid （3）锚点 1.开始：^匹配字符串的开头 如果m启用了多行标志 ( )，则匹配一行的开头。这匹配一个位置，而不是一个字符 例子：^\\w+ 匹配：she sells seashells 2.结尾：$匹配字符串的结尾 如果m启用了多行标志 ( )，则匹配一行的结尾。这匹配一个位置，而不是一个字符 例子：\\w+$ 匹配：she sells seashells 3.单词边界：\\b匹配单词字符和非单词字符或位置（字符串的开始/结束）之间的单词边界位置 例子：s\\b 匹配：she sells seashells 4.非单词边界：\\B匹配任何不是单词边界的位置 这匹配一个位置，而不是一个字符。 例子：s\\B 匹配：she sells seashells 参考 ","date":"2023-02-26","objectID":"/regex/:0:1","tags":["Regex","Blog"],"title":"正则表达式初识","uri":"/regex/"},{"categories":null,"content":"DOS(磁盘操作系统) 1. 文件夹操作 lists 当前目录下的所有文件 $ ls change directory 进入指定目录 cd \u003cpath to directory\u003e /* 切换到主目录 */ cd ~ /* 切换到父目录 */ cd .. -make a new directory 用给定的名称创建一个新目录 mkdir \u003cdirectory name\u003e move the file 将给定源的文件移动到给定的目标 mv \u003csource path\u003e \u003cdestination path\u003e ","date":"2023-02-07","objectID":"/memo/2023/:0:1","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"Windows PowerShell 命令摘要 1. 文件夹操作 解压指定目录下的文件 Expand-Archive -\u003cDestinationPath\u003e . -Force \u003czipFile\u003e 常用操作 在任意文件目录下：shift + 右键单击“在此处打开PowerShell窗口”将会自动切换到该文件目录 ","date":"2023-02-07","objectID":"/memo/2023/:0:2","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"Git Bash 命令摘要 1. 文件夹操作 解压指定目录下的文件 unzip \u003czipFile\u003e 常用操作 ctrl + c 退出命令行模式 ","date":"2023-02-07","objectID":"/memo/2023/:0:3","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"IDEA相关 1. 创建Javafx-Maven项目 step1- 创建Javfx项目 File-New-Project-Java FX-Next-Finish step2- 添加Maven框架 右键点击项目-Add Framework Support-Maven-Ok step3- 在 Project Structrue-Modules-Sources 按下图设置项目文件目录 step4- 将自动生成的fxml文件移动到resources/fxml/下，注意导入Maven以后必须用一个前导斜杠调用它，比如： FXMLLoader.load(getClass().getResource(\"/fxml/sample.fxml\")) 2. 显示version control 点击VCS-Browse VCS Respository-Show Git Respository Log || 取消勾选File-Settings-Version Control-Commit-[Use non-modal commit interface] ","date":"2023-02-07","objectID":"/memo/2023/:0:4","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"JAVA 经验总结 总结\r1.程序异常时——\u003e检查程序本身逻辑 ——»是否由未被捕获的异常（比如空指针）导致——»\u003e在可能出现异常的地方用try-catch包出再调试 ——»是否由未被识别的命名冲突导致 Runtime类 —— 程序调用外部exe 摘要\rJava 中，Runtime 类用于与每个 Java 应用程序交互，每个 Java 应用程序都有一个 Runtime 类的单个实例，允许应用程序与应用程序运行的环境进行交互\r/** * 调用外部exe程序并通过process.getInputStream()捕获外部程序的输出流，然后System.out * to learn: 对于应用程序来说，其输出流有两种： 标准输出流 标准错误流 因此，一个健壮的代码应同时对这两种输出流进行处理 */ class RuntimeTest{ public static void main(String[] args) throws IOException { final Process process = Runtime.getRuntime().exec(\"E:\\\\xx\\\\xx.exe\"); //get input stream handleProcessStreamByLine(process.getInputStream()); handleProcessStreamByBytes(process, process.getInputStream()); //get error stream handleProcessStreamByLine(process.getErrorStream()); handleProcessStreamByBytes(process, process.getErrorStream()); //to learn: 验证外部程序是否执行成功 // Process.exitValue()/Process.waitFor() 获取外部程序的返回值为 0 表示执行成功，其余值表示外部程序执行出错 try { int exitValue = process.waitFor(); System.out.println(\"process exitValue:\" + exitValue); } catch (Exception e) { e.printStackTrace(); } } private void handleProcessStreamByLine(InputStream streamToHandle) { new Thread(() -\u003e { BufferedReader br = new BufferedReader(new InputStreamReader(streamToHandle)); String line; try { while ((line = br.readLine()) != null) { System.out.println(line); } br.close(); } catch (IOException e) { e.printStackTrace(); } }).start(); } private void handleProcessStreamByBytes(Process process, InputStream streamToHandle){ new Thread(() -\u003e { try { while (process.isAlive()) { int length = streamToHandle.available(); if (length \u003e 0) { byte[] bytes = new byte[streamToHandle.available()]; streamToHandle.read(bytes); System.out.println(new String(bytes)); } } streamToHandle.close(); } catch (IOException e) { e.printStackTrace(); } }).start(); } } ","date":"2023-02-07","objectID":"/memo/2023/:0:5","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"JAVAFX TabPane \u003cTabPane prefHeight=\"100.0\" prefWidth=\"200.0\"\u003e \u003cTab fx:id=\"tab1\" closable=\"false\" text=\"tab1\"\u003e \u003cfx:include source=\"options/tab1.fxml\"/\u003e \u003c/Tab\u003e \u003cTab fx:id=\"tab2\" onClosed=\"#closeTabEvent\" text=\"tab2\"\u003e \u003cfx:include source=\"options/tab2.fxml\"/\u003e \u003c/Tab\u003e \u003c/TabPane\u003e 细节注意\r1.closable=false表示此tab不可以关闭 2.onClosed事件在关闭tab后触发 3.source的路径的根目录是fxml。比如resources/fxml/options/.. ###树莓派 在Raspberry Pi上打开一个终端窗口，可以通过单击桌面上的“终端”图标或Ctrl+Alt+T。 ###Linux命令 #浏览已安装的程序 dpkg --list #查看文件权限和所有者等详细信息 ls -l filename ","date":"2023-02-07","objectID":"/memo/2023/:0:6","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":null,"content":"其它 检索小技巧 搜索任意API文档 包名关键字+Java doc 1.下载任意网页的图标（favicon） 地址搜索栏：域名/favicon.ico 2.项目启动端口被占用的解决办法 1.查看被占用的端口进程：15490是被占用的端口号 netstat -aon|findtr 15490 -\u003e TCP 127.0.0.1:15490 0.0.0.0:0 2.根据PID找到被占用端口的进程：15248是PID tasklist|findstr 15248 -\u003e v2ray.exe 15248 Console 4 26,032 K 3.通过进程名称终止进程 taskkill /f /t /im v2ray.exe -\u003e 成功: 已终止 PID 15248 (属于 PID 15156 子进程)的进程 ","date":"2023-02-07","objectID":"/memo/2023/:0:7","tags":null,"title":"2023","uri":"/memo/2023/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 一、使用CSS重新设置现有控件的样式 二、组合现有控件来创建自定义控件 三、扩展现有控件 使用Control plus Skin类 五、使用Region类 前言\r上一篇文章展示了如何基于控件加皮肤方法创建自定义控件，这对于构建控件库非常有用。这一章将展示如何创建基于 JavaFX Region 类的 JavaFX 自定义控件； Region 类是所有 JavaFX 控件所基于的类。它是一个可调整大小的父节点，可以从 CSS 设置样式。这是您在构建不属于控件库的 JavaFX 自定义控件时希望使用的类。 ","date":"2023-02-05","objectID":"/customcontrols05/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（五）- 使用Region类来自定义全新的组件","uri":"/customcontrols05/"},{"categories":["JavaFx"],"content":"使用Region的实现类来自定义全新的组件 使用Region类的方法和基于 Control + Skin 的方法之间的主要区别在于：基于Region 的控件同时包含控制逻辑和 UI，而基于 Control + Skin 的控件将 逻辑与 UI 分开。逻辑可以在控件中找到，用户界面可以在皮肤中找到。 步骤1：将控件屏幕截图拖入到PS中，在截图上绘制控件副本 通过这种方法可以直接获得正确的屏幕尺寸、位置和颜色 演示\r步骤2：使用SVG矢量绘图程序手动绘制符号svg 将绘制好的符号路径添加到基于区域的控件的css代码中 ","date":"2023-02-05","objectID":"/customcontrols05/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（五）- 使用Region类来自定义全新的组件","uri":"/customcontrols05/"},{"categories":["JavaFx"],"content":"示例demo 信息\r自定义组合组件示例 ：一个可以通过点击右边按钮来让文本域切换相应的值的组合组件——实现℃和°F 的转换功能 正常状态\r`鼠标悬停前后`\r悬停状态\r更有趣的是我们需要创建的 CSS 文件，因为它包含了 UI 的所有“魔法”。所以这里是： .region-based { /* 预定义变量 */ -RED : #ff6058; -YELLOW : #ffbc35; -GREEN : #00c844; -GRAY : #535353; -DARK_GRAY: #343535; } .region-based .circle { -fx-stroke-width: 0.5px; } .region-based:close .circle, .region-based:close:hovered .circle { -fx-fill : -RED; /*derive(指定颜色, 在指定颜色基础上加深X%)*/ -fx-stroke: derive(-RED, -10%); } .region-based:close:pressed .circle { -fx-fill : derive(-RED, -20%); -fx-stroke: derive(-RED, -30%); } .region-based:minimize .circle, .region-based:minimize:hovered .circle { -fx-fill : -YELLOW; -fx-stroke: derive(-YELLOW, -5%); } .region-based:minimize:pressed .circle { -fx-fill : -YELLOW; -fx-stroke: derive(-YELLOW, -10%); } .region-based:zoom .circle, .region-based:zoom:hovered .circle { -fx-fill : -GREEN; -fx-stroke: derive(-GREEN, -10%); } .region-based:zoom:pressed .circle { -fx-fill : derive(-GREEN, -20%); -fx-stroke: derive(-GREEN, -30%); } .region-based:disabled:close .circle, .region-based:disabled:minimize .circle, .region-based:disabled:zoom .circle { -fx-fill : -GRAY; -fx-stroke: transparent; } .region-based:close .symbol, .region-based:minimize .symbol, .region-based:zoom .symbol { -fx-background-color: transparent; } .region-based:hovered:close .symbol { -fx-background-color: -DARK_GRAY; -fx-border-color : -DARK_GRAY; -fx-scale-shape : false; -fx-shape : \"M6.001,5.429l2.554,-2.555l0.571,0.571l-2.555,2.554l2.55,2.55l-0.572,0.572l-2.55,-2.55l-2.554,2.555l-0.571,-0.571l2.555,-2.554l-2.55,-2.55l0.572,-0.572l2.55,2.55Z\"; } .region-based:hovered:minimize .symbol { -fx-background-color: -DARK_GRAY; -fx-scale-shape : false; -fx-shape : \"M2.0,5.5l8,0l0,1l-8,0l0,-1Z\"; } .region-based:hovered:zoom .symbol { -fx-background-color: -DARK_GRAY; -fx-scale-shape : false; -fx-shape : \"M2.696,2.582l4.545,0.656l-3.889,3.889l-0.656,-4.545ZM9.533,9.418l-0.656,-4.545l-3.889,3.889l4.545,0.656Z\"; } .region-based:hovered:zoom:state .symbol { -fx-background-color: -DARK_GRAY; -fx-scale-shape : false; -fx-shape : \"M6.225,6.111L10.77,6.767L6.881,10.656L6.225,6.111ZM6.004,5.889L5.348,1.344L1.459,5.233L6.004,5.889Z\"; } 信息\r如前所述，我们知道我们需要的所有颜色，因此我们可以直接在我们的 CSS 文件中定义它们。我们有不同状态（-RED、-YELLOW、-GREEN）、禁用状态（-GRAY）和符号（-DARK_GRAY）的颜色。 原始的 MacOS 按钮看起来有一个内部阴影或一个比填充颜色暗一点的边框。为此，我们将描边设置为 0.5px。这也意味着我们必须定义比填充颜色深一点的描边颜色。 这可以通过使用 derive 方法在 JavaFX CSS 中轻松完成。如果我们想创建一个颜色较深的红色边框，我们可以按如下方式实现： -fx-stroke: derive(-RED, -10%); 此代码将根据为 -RED 定义的颜色创建一种颜色，该颜色比给定颜色深 10%。 package com.ryl.custom.regionBased; import javafx.beans.property.BooleanProperty; import javafx.beans.property.BooleanPropertyBase; import javafx.beans.property.ObjectProperty; import javafx.beans.property.ObjectPropertyBase; import javafx.css.PseudoClass; import javafx.scene.input.MouseEvent; import javafx.scene.layout.Region; import javafx.scene.shape.Circle; import javafx.scene.shape.StrokeType; import java.util.function.Consumer; /** * @author hansolo */ public class RegionControl extends Region { public enum Type {CLOSE, MINIMIZE, ZOOM} private static final double PREFERRED_WIDTH = 12; private static final double PREFERRED_HEIGHT = 12; private static final PseudoClass CLOSE_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"close\"); private static final PseudoClass MINIMIZE_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"minimize\"); private static final PseudoClass ZOOM_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"zoom\"); private static final PseudoClass HOVERED_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"hovered\"); private static final PseudoClass PRESSED_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"pressed\"); private static final PseudoClass STATE_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"state\"); private BooleanProperty hovered; private BooleanProperty state; private static String userAgentStyleSheet; private ObjectProperty\u003cType\u003e type; private double size; private double width; private double height; private Circle circle; private Region symbol; private Consumer\u003cMouseEvent\u003e","date":"2023-02-05","objectID":"/customcontrols05/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（五）- 使用Region类来自定义全新的组件","uri":"/customcontrols05/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part 5) HanSolo/JavaFXCustomControls(github) ","date":"2023-02-05","objectID":"/customcontrols05/:0:4","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（五）- 使用Region类来自定义全新的组件","uri":"/customcontrols05/"},{"categories":null,"content":"\r","date":"2023-02-02","objectID":"/memo/2024/:0:0","tags":null,"title":"2024","uri":"/memo/2024/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 一、使用CSS重新设置现有控件的样式 二、组合现有控件来创建自定义控件 三、扩展现有控件 使用Control plus Skin类 五、使用Region类 ","date":"2022-06-08","objectID":"/customcontrols04/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"使用Control plus Skin的实现类来自定义全新的组件 Control 将包含所有逻辑，而 Skin 将包含所有 UI 相关代码 步骤1：通过矢量绘图程序绘制好组件 演示\r步骤2：将矢量图形转换成css代码 步骤3：创建程序，引用css ","date":"2022-06-08","objectID":"/customcontrols04/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"示例demo 示例\r自定义全新组件示例 ：展示如何使用 Control 和 Skin 类在 JavaFX 中创建自定义控件—LED开关 注意： 由 Control 和 Skin 类创建的自定义控件只有在您为控件提供多个皮肤或者您希望让人们能够为您的控件创建自己的皮肤时才有意义。在任何其他情况下，您应该选择另一种方法（例如，使用基于区域或画布的控件）。因此，通常在 UI 库中使用 Control 和 Skin 方法，其中您有一个 Control 和多个 Skin。 LED\rpackage controlskin; import javafx.application.Application; import javafx.geometry.Insets; import javafx.scene.Scene; import javafx.scene.layout.VBox; import javafx.scene.paint.Color; import javafx.stage.Stage; import controlskin.CustomControl.SkinType; /** * @author Gerrit Grunwald * Description: 全新自定义组件程序demo */ public class DemoControlSkinBased extends Application { private CustomControl ledControl; private CustomControl switchControl; @Override public void init() throws Exception { ledControl = new CustomControl(); ledControl.setState(true); ledControl.setPrefSize(100, 100); ledControl.setColor(Color.LIME); switchControl = new CustomControl(SkinType.SWITCH); switchControl.setState(true); switchControl.setColor(Color.web(\"#4bd865\")); switchControl.stateProperty().addListener((o, ov, nv) -\u003e ledControl.setState(nv)); } @Override public void start(Stage stage) throws Exception { VBox pane = new VBox(20, ledControl, switchControl); pane.setPadding(new Insets(20)); Scene scene = new Scene(pane, 200, 200); scene.getStylesheets().add(DemoControlSkinBased.class.getResource(\"/styles.css\").toExternalForm()); stage.setTitle(\"Control-Skin based Control\"); stage.setScene(scene); stage.show(); } @Override public void stop() throws Exception { super.stop(); } } ","date":"2022-06-08","objectID":"/customcontrols04/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"Control 前言\r控件需要两个属性，第一个应该定义 LED 的状态，第二个应该定义 LED 的颜色; 众所周知，我们有能力在 JavaFX 中使用 CSS 来设置控件样式，问题是我们如何将 CSS 属性链接到我们在代码中定义的属性？ 答案是使用所谓的 StyleableProperties。这个属性有一个指向 CSS 属性的链接，这意味着如果我们加载一个覆盖例如 -color 属性的 CSS 文件，它将触发我们在代码中定义的属性。这很棒，因为我们可以通过在代码中调用 setColor() 方法或加载覆盖 -color 属性的 CSS 文件来更改属性； 最后，我们需要一个 BooleanProperty 来表示控件的状态。为此，我们还可以利用 JavaFX 中的 CSS 特性，即 CSS PseudoClass。这可以看作是一个布尔开关，如果在 CSS 中触发，则可用于为真/假状态定义单独的样式。 package controlskin; import javafx.beans.property.BooleanProperty; import javafx.beans.property.BooleanPropertyBase; import javafx.beans.property.ObjectProperty; import javafx.css.*; import javafx.scene.control.Control; import javafx.scene.control.Skin; import javafx.scene.paint.Color; import java.util.List; /** * @author Gerrit Grunwald * description：全新自定义的控件——实现功能：开关切换 */ public class CustomControl extends Control { public enum SkinType{ LED, SWITCH } private static final StyleablePropertyFactory\u003cCustomControl\u003e FACTORY = new StyleablePropertyFactory\u003c\u003e(Control.getClassCssMetaData()); /** css样式属性 **/ private static final CssMetaData\u003cCustomControl, Color\u003e COLOR = FACTORY.createColorCssMetaData(\"-color\", s -\u003e s.color, Color.RED, false); /** css伪类 **/ private static final PseudoClass ON_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"on\"); /** Properties **/ private SkinType skinType; private BooleanProperty state; private final StyleableProperty\u003cColor\u003e color; /** 用户代理样式表 **/ private static String defaultUserAgentStyleSheet; private static String switchUserAgentStyleSheet; /** * 构造器重载 */ public CustomControl() { this(SkinType.LED); } public CustomControl(final SkinType skinType){ getStyleClass().add(\"custom-control\"); this.skinType = skinType; this.state = new BooleanPropertyBase(false){ @Override protected void invalidated(){ pseudoClassStateChanged(ON_PSEUDO_CLASS,get()); } @Override public Object getBean() { return this; } @Override public String getName() { return \"state\"; } }; this.color = new SimpleStyleableObjectProperty\u003c\u003e(COLOR,this,\"color\"); } /** * state */ public boolean getState(){ return state.get(); } public void setState(final boolean state) { this.state.set(state); } public BooleanProperty stateProperty() { return state; } /** * color */ public Color getColor() { return color.getValue(); } public void setColor(final Color color){ this.color.setValue(color); } public ObjectProperty\u003cColor\u003e colorProperty(){ return (ObjectProperty\u003cColor\u003e) color; } /** * style related */ @Override protected Skin\u003c?\u003e createDefaultSkin() { switch (skinType){ case SWITCH: return new SwitchSkin(CustomControl.this); case LED: default: return new LedSkin(CustomControl.this); } } @Override public String getUserAgentStylesheet() { switch(skinType) { case SWITCH: if (null == switchUserAgentStyleSheet) { switchUserAgentStyleSheet = CustomControl.class.getResource(\"/switch.css\").toExternalForm(); } return switchUserAgentStyleSheet; case LED : default : if (null == defaultUserAgentStyleSheet) { defaultUserAgentStyleSheet = CustomControl.class.getResource(\"/custom-control.css\").toExternalForm(); } return defaultUserAgentStyleSheet; } } @Override public List\u003cCssMetaData\u003c? extends Styleable, ?\u003e\u003e getControlCssMetaData() { return FACTORY.getCssMetaData(); } } 总结\r通过css样式属性定义了一个名为COLOR的 CssMetaData 对象，而这个对象又定义了将在 CSS 中使用的属性-color； 再去css文件中定义这个属性，比如紫色部分： .custom-control { -color: red; } PseudoClass ON_PSEUDO_CLASS 定义了到 CSS 伪类“on”的链接，为了使用它，我们通过调用 pseudoClassStateChanged(ON_PSEUDO_CLASS.get()) 在 state 属性的 invalidated() 方法中触发它; 为了完成这项工作，我们还需要 CSS 文件中的 on 伪类。请记住，主要 LED 部分（绿色部分）是在 LED 亮起时应从深绿色渐变变为浅绿色渐变的部分。下面是实现此效果所需的 CSS 代码： .custom-control .main { -fx-background-color : linear-gradient(from 15% 15% to 83% 83%, derive(-color, -80%) 0%, derive(-color, -87%) 49%, derive(-color, -80%) 100%); -fx-background-radius: 1024px; } .custom-control:on .main { -fx-background-color: linear-gradient(from 15% 15% to 83% 83%, derive(-color, -23%) 0%, derive(-color, -50%) 49%, -color 100%); } 我们定义了一个具有 LED 和 SWITCH 的枚举 SkinType，它们将在 getUserAgentStyleSheet() 方法中使用。根据 skinType 变量加载不同的样式表","date":"2022-06-08","objectID":"/customcontrols04/:0:4","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"Skin LED package controlskin; import javafx.beans.InvalidationListener; import javafx.scene.control.SkinBase; import javafx.scene.effect.BlurType; import javafx.scene.effect.DropShadow; import javafx.scene.effect.InnerShadow; import javafx.scene.layout.Region; import javafx.scene.paint.Color; /** * @author Gerrit Grunwald * description：led皮肤 */ public class LedSkin extends SkinBase\u003cCustomControl\u003e { private static final double PREFERRED_WIDTH = 16; private static final double PREFERRED_HEIGHT = 16; private static final double MINIMUM_WIDTH = 8; private static final double MINIMUM_HEIGHT = 8; private static final double MAXIMUM_WIDTH = 1024; private static final double MAXIMUM_HEIGHT = 1024; private double size; /** 组件 **/ private Region frame; private Region main; private Region highlight; private InnerShadow innerShadow; private DropShadow glow; /** 自定义组件 **/ private CustomControl control; /** 监听器 **/ private final InvalidationListener sizeListener; private final InvalidationListener colorListener; private final InvalidationListener stateListener; /** * 构造器 * @param control 自定义组件 */ public LedSkin(final CustomControl control) { super(control); this.control = control; sizeListener = o -\u003e handleControlPropertyChanged(\"RESIZE\"); colorListener = o -\u003e handleControlPropertyChanged(\"COLOR\"); stateListener = o -\u003e handleControlPropertyChanged(\"STATE\"); initGraphics(); registerListeners(); } /** * 初始化 */ private void initGraphics() { if (Double.compare(control.getPrefWidth(), 0.0) \u003c= 0 || Double.compare(control.getPrefHeight(), 0.0) \u003c= 0 || Double.compare(control.getWidth(), 0.0) \u003c= 0 || Double.compare(control.getHeight(), 0.0) \u003c= 0) { if (control.getPrefWidth() \u003e 0 \u0026\u0026 control.getPrefHeight() \u003e 0) { control.setPrefSize(control.getPrefWidth(), control.getPrefHeight()); } else { control.setPrefSize(PREFERRED_WIDTH, PREFERRED_HEIGHT); } } frame = new Region(); frame.getStyleClass().setAll(\"frame\"); main = new Region(); main.getStyleClass().setAll(\"main\"); main.setStyle(String.join(\"\", \"-color: \", control.getColor().toString().replace(\"0x\", \"#\"), \";\")); innerShadow = new InnerShadow(BlurType.TWO_PASS_BOX, Color.rgb(0, 0, 0, 0.65), 8, 0, 0, 0); glow = new DropShadow(BlurType.TWO_PASS_BOX, control.getColor(), 20, 0, 0, 0); glow.setInput(innerShadow); highlight = new Region(); highlight.getStyleClass().setAll(\"highlight\"); getChildren().addAll(frame, main, highlight); } /** * 添加监听器 */ private void registerListeners() { control.widthProperty().addListener(sizeListener); control.heightProperty().addListener(sizeListener); control.colorProperty().addListener(colorListener); control.stateProperty().addListener(stateListener); } @Override protected double computeMinWidth(final double height, final double top, final double right, final double bottom, final double left) { return MINIMUM_WIDTH; } @Override protected double computeMinHeight(final double width, final double top, final double right, final double bottom, final double left) { return MINIMUM_HEIGHT; } @Override protected double computePrefWidth(final double height, final double top, final double right, final double bottom, final double left) { return super.computePrefWidth(height, top, right, bottom, left); } @Override protected double computePrefHeight(final double width, final double top, final double right, final double bottom, final double left) { return super.computePrefHeight(width, top, right, bottom, left); } @Override protected double computeMaxWidth(final double width, final double top, final double right, final double bottom, final double left) { return MAXIMUM_WIDTH; } @Override protected double computeMaxHeight(final double width, final double top, final double right, final double bottom, final double left) { return MAXIMUM_HEIGHT; } /** * 处理控件属性变化 */ protected void handleControlPropertyChanged(final String property) { if (\"RESIZE\".equals(property)) { resize(); } else if (\"COLOR\".equals(property)) { main.setStyle(String.join(\"\", \"-color: \", (control.getColor()).toString().repla","date":"2022-06-08","objectID":"/customcontrols04/:0:5","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"CSS LED .custom-control .frame { -fx-background-color : linear-gradient(from 14% 14% to 84% 84%, rgba(20, 20, 20, 0.64706) 0%, rgba(20, 20, 20, 0.64706) 15%, rgba(41, 41, 41, 0.64706) 26%, rgba(200, 200, 200, 0.40631) 85%, rgba(200, 200, 200, 0.3451) 100%); -fx-background-radius: 1024px; } .custom-control .main { -fx-background-color : linear-gradient(from 15% 15% to 83% 83%, derive(-color, -80%) 0%, derive(-color, -87%) 49%, derive(-color, -80%) 100%); -fx-background-radius: 1024px; } .custom-control:on .main { -fx-background-color: linear-gradient(from 15% 15% to 83% 83%, derive(-color, -23%) 0%, derive(-color, -50%) 49%, -color 100%); } .custom-control .highlight { -fx-background-color : radial-gradient(center 15% 15%, radius 50%, white 0%, transparent 100%); -fx-background-radius: 1024; } 总结\r在该CSS 文件中，实际上只是定义了每个区域的背景半径和始终为渐变的绘制； 通过触发 :on 伪类，我们只会将渐变从较暗的版本更改为较亮的版本，仅此而已。 Switch .custom-control .switch-background { -fx-pref-width : 76; -fx-pref-height : 46; -fx-min-width : 76; -fx-min-height : 46; -fx-max-width : 76; -fx-max-height : 46; -fx-background-radius: 1024; -fx-background-color : #a3a4a6; } .custom-control:on .switch-background { -fx-background-radius: 1024; -fx-background-color : -color; } .custom-control .thumb { -fx-translate-x : 2; -fx-translate-y : 2; -fx-pref-width : 42; -fx-pref-height : 42; -fx-min-width : 42; -fx-min-height : 42; -fx-max-width : 42; -fx-max-height : 42; -fx-background-radius: 1024; -fx-background-color : white; -fx-effect : dropshadow(two-pass-box, rgba(0, 0, 0, 0.3), 1, 0.0, 0, 1); } Styles 演示\r.custom-control { -color: magenta; } 技巧\r通过添加场景样式表覆盖 CSS 文件中的一个属性-color，控件属性就会被覆盖，而无需更改代码，这显示了 CSS 的强大功能： scene.getStylesheets().add(ClassNameHere.class.getResource(\"/styles.css\").toExternalForm()); .custom-control { -color: magenta; } ","date":"2022-06-08","objectID":"/customcontrols04/:0:6","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part 4) HanSolo/JavaFXCustomControls(github) adobe illustrator to CSS——矢量绘图程序：视觉编码之操作文档 ","date":"2022-06-08","objectID":"/customcontrols04/:0:7","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（四）- 使用Control plus Skin的实现类来自定义全新的组件","uri":"/customcontrols04/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 一、使用CSS重新设置现有控件的样式 二、组合现有控件来创建自定义控件 三、扩展现有控件 四、使用Control + Skin类 五、使用Region类 ","date":"2022-06-06","objectID":"/customcontrols03/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（三）- 扩展现有控件来创建自定义控件","uri":"/customcontrols03/"},{"categories":["JavaFx"],"content":"扩展现有控件来生成自定义控件 示例\r自定义扩展组件示例 ：根据焦点状态添加文本的动画组件\r成果\rpackage extended; import javafx.application.Application; import javafx.application.Platform; import javafx.geometry.Insets; import javafx.scene.Scene; import javafx.scene.control.Button; import javafx.scene.layout.VBox; import javafx.stage.Stage; /** * @author Gerrit Grunwald */ public class DemoExtended extends Application { private ExtendedControl control; private Button button; @Override public void init() { control = new ExtendedControl(); control.setPromptText(\"Name\"); button = new Button(\"Focus\"); } @Override public void start(final Stage stage) { VBox pane = new VBox(24, control, button); pane.setPadding(new Insets(20)); Scene scene = new Scene(pane); stage.setTitle(\"Extended\"); stage.setScene(scene); stage.show(); button.requestFocus(); } @Override public void stop() { Platform.exit(); System.exit(0); } public static void main(String[] args) { launch(args); } } package extended; import javafx.animation.KeyFrame; import javafx.animation.KeyValue; import javafx.animation.Timeline; import javafx.beans.property.DoubleProperty; import javafx.beans.property.ObjectProperty; import javafx.beans.property.SimpleDoubleProperty; import javafx.css.*; import javafx.scene.control.TextField; import javafx.scene.layout.HBox; import javafx.scene.paint.Color; import javafx.scene.text.Font; import javafx.scene.text.Text; import javafx.util.Duration; import java.util.List; /** * @author Gerrit Grunwald * Here are the things we need to do... * * 1.Extend the JavaFX TextField * 2.Add a Text to it that can be set using the promptTextProperty * 3.Add animation of the Text dependent on the focus state * 4.Add some CSS styling */ public class ExtendedControl extends TextField { private static final StyleablePropertyFactory\u003cExtendedControl\u003e FACTORY = new StyleablePropertyFactory\u003c\u003e(TextField.getClassCssMetaData()); private static final double STD_FONT_SIZE = 13; private static final double SMALL_FONT_SIZE = 10; private static final double TOP_OFFSET_Y = 4; private static final int ANIMATION_DURATION = 60; /** 组件 **/ private Text promptText; private HBox promptTextBox; /** paint **/ private static final Color DEFAULT_MATERIAL_DESIGN_COLOR = Color.web(\"#009688\"); private static final Color DEFAULT_PROMPT_TEXT_COLOR = Color.web(\"#757575\"); /** 动画时间线 **/ private Timeline timeline; /** Properties **/ private final StyleableProperty\u003cColor\u003e materialDesignColor; private final StyleableProperty\u003cColor\u003e promptTextColor; private DoubleProperty fontSize; /** 用户代理样式表 **/ private static String userAgentStyleSheet; /** css样式属性 **/ private static final CssMetaData\u003cExtendedControl, Color\u003e MATERIAL_DESIGN_COLOR = FACTORY.createColorCssMetaData (\"-material-design-color\", s -\u003e s.materialDesignColor, DEFAULT_MATERIAL_DESIGN_COLOR, false); private static final CssMetaData\u003cExtendedControl, Color\u003e PROMPT_TEXT_COLOR = FACTORY.createColorCssMetaData (\"-prompt-text-color\", s -\u003e s.promptTextColor, DEFAULT_PROMPT_TEXT_COLOR, false); public ExtendedControl() { this(\"\"); } public ExtendedControl(final String promptTextBox) { super(promptTextBox); materialDesignColor = new SimpleStyleableObjectProperty\u003c\u003e(MATERIAL_DESIGN_COLOR, this, \"materialDesignColor\"); promptTextColor = new SimpleStyleableObjectProperty\u003c\u003e(PROMPT_TEXT_COLOR, this, \"promptTextColor\"); fontSize = new SimpleDoubleProperty(ExtendedControl.this, \"fontSize\", getFont().getSize()); timeline = new Timeline(); initGraphics(); registerListeners(); } /** * 初始化 */ private void initGraphics() { getStyleClass().addAll(\"material-field\"); final String fontFamily = getFont().getFamily(); final int length = getText().length(); promptText = new Text(getPromptText()); promptText.getStyleClass().add(\"prompt-text\"); promptTextBox = new HBox(promptText); promptTextBox.getStyleClass().add(\"material-field\"); if (!isEditable() || isDisabled() || length \u003e 0) { promptText.setFont(Font.font(fontFamily, SMALL_FONT_SIZE)); promptTextBox.setTranslateY(-STD_FONT_SIZE - TOP_OFFSET_Y); } else { pro","date":"2022-06-06","objectID":"/customcontrols03/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（三）- 扩展现有控件来创建自定义控件","uri":"/customcontrols03/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part 3) HanSolo/JavaFXCustomControls(github) ","date":"2022-06-06","objectID":"/customcontrols03/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（三）- 扩展现有控件来创建自定义控件","uri":"/customcontrols03/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 一、使用CSS重新设置现有控件的样式 二、组合现有控件来创建自定义控件 三、扩展现有控件 四、使用Control + Skin类 五、使用Region类 ","date":"2022-06-06","objectID":"/customcontrols02/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（二）- 组合现有控件来创建自定义控件","uri":"/customcontrols02/"},{"categories":["JavaFx"],"content":"组合现有控件来创建自定义控件 示例\r自定义组合组件示例 ：一个可以通过点击右边按钮来让文本域切换相应的值的组合组件——实现℃和°F 的转换功能 添加css样式表前\r`添加css样式表前后`\r添加css样式表后\rpackage extended; import javafx.application.Application; import javafx.application.Platform; import javafx.geometry.Insets; import javafx.scene.Scene; import javafx.scene.control.Button; import javafx.scene.layout.VBox; import javafx.stage.Stage; /** * @author Gerrit Grunwald */ public class DemoExtended extends Application { private ExtendedControl control; private Button button; @Override public void init() { control = new ExtendedControl(); control.setPromptText(\"Name\"); button = new Button(\"Focus\"); } @Override public void start(final Stage stage) { VBox pane = new VBox(24, control, button); pane.setPadding(new Insets(20)); Scene scene = new Scene(pane); stage.setTitle(\"Extended\"); stage.setScene(scene); stage.show(); button.requestFocus(); } @Override public void stop() { Platform.exit(); System.exit(0); } public static void main(String[] args) { launch(args); } } package comb; import javafx.geometry.Pos; import javafx.scene.control.Button; import javafx.scene.control.TextField; import javafx.scene.control.TextFormatter; import javafx.scene.layout.HBox; import java.util.Locale; /** * @author Azad-eng * Description: 组合组件类——由TextField和Button组成的自定义实现特定功能的HBox组件, * 作用是实现摄氏度和华氏度的值的转换 */ public class CombinedControl extends HBox { private TextField textField; private Button button; public CombinedControl() { init(); getStyleClass().setAll(\"combined-control\"); registerListeners(); } private void init() { textField = new TextField(); textField.setFocusTraversable(false); textField.setTextFormatter( new TextFormatter\u003c\u003e(change -\u003e change.getText().matches(\"[0-9]*(\\\\.[0-9]*)?\") ? change : null)); button = new Button(\"°C\"); button.setFocusTraversable(false); setSpacing(0); setFillHeight(false); setAlignment(Pos.CENTER); getChildren().addAll(textField, button); } private void registerListeners() { button.setOnMousePressed(e -\u003e handleControlPropertyChanged(\"BUTTON_PRESSED\")); } private void handleControlPropertyChanged(final String PROPERTY) { if (\"BUTTON_PRESSED\".equals(PROPERTY)) { String buttonText = button.getText(); String text = textField.getText(); if (text.matches(\"^[-+]?\\\\d+(\\\\.\\\\d+)?$\")) { if (\"°C\".equals(buttonText)) { // Convert to Fahrenheit button.setText(\"°F\"); textField.setText(toFahrenheit(textField.getText())); } else { // Convert to Celsius button.setText(\"°C\"); textField.setText(toCelsius(textField.getText())); } } } } private String toFahrenheit(final String text) { try { double celsius = Double.parseDouble(text); return String.format(Locale.US, \"%.2f\", (celsius * 1.8 + 32)); } catch (NumberFormatException e) { return text; } } private String toCelsius(final String text) { try { double fahrenheit = Double.parseDouble(text); return String.format(Locale.US, \"%.2f\", ((fahrenheit - 32) / 1.8)); } catch (NumberFormatException e) { return text; } } } /*这是样式表，让控件内部的两个小组件视觉上仿若一体*/ .combined-control:focused { -fx-highlight-fill : -fx-accent; -fx-background-color : -fx-focus-color, -fx-control-inner-background, -fx-faint-focus-color; -fx-background-insets: -1.2, 1, -2.4; -fx-background-radius: 3, 2, 4, 0; -fx-border-color : -fx-faint-focus-color; -fx-border-insets : -1; } .combined-control:focused \u003e .button { -fx-background-color : -fx-focus-color, -fx-outer-border, -fx-inner-border, -fx-body-color, -fx-faint-focus-color, -fx-body-color; -fx-background-insets: -0.2 -0.2 -0.2 1, 1 1 1 0, 1 1 1 1, 2, -1.4 -1.4 -1.4 1, 2.6; -fx-background-radius: 0 3 3 0, 0 2 2 0, 0 1 1 0, 0 4 4 0, 0 1 1 0; } .combined-control \u003e .text-input, .combined-control \u003e .text-input:focused { -fx-background-color : linear-gradient(to bottom, derive(-fx-text-box-border, -10%), -fx-text-box-border), linear-gradient(from 0px 0px to 0px 5px, derive(-fx-control-inner-background, -9%), -fx-control-inner-background); -fx-background-insets : 0, 1 0 1 1; -fx-background-radius : 3 0 0 3, 2 0 0 2; -fx-pref-width : 120px; } .combined-control \u003e .button { -fx-backgr","date":"2022-06-06","objectID":"/customcontrols02/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（二）- 组合现有控件来创建自定义控件","uri":"/customcontrols02/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part 2) HanSolo/JavaFXCustomControls(github) ","date":"2022-06-06","objectID":"/customcontrols02/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（二）- 组合现有控件来创建自定义控件","uri":"/customcontrols02/"},{"categories":["JavaFx"],"content":"前言 为什么需要自定义控件？\rJavaFx中很多内置控件的代码都是私有的或最终的，因此无法访问或覆盖它们的内部结构，当涉及到个性化的需求时，就会束手无策 当需要定制一个全新的符合项目需求的组件，而JavaFX中内置的组件无法满足需求 ","date":"2022-06-06","objectID":"/customcontrols01/:0:1","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"导航 创建自定义控件的不同方法 一、使用CSS重新设置现有控件的样式 二、组合现有控件来创建自定义控件 三、扩展现有控件 四、使用Control + Skin类 五、使用Region类 ","date":"2022-06-06","objectID":"/customcontrols01/:0:2","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"具体实现 步骤1：在 modena.css 文件中获取指定控件的css样式 modena.css 是包含JavaFx内置的每个控件的所有css样式的文件，其前身是 caspian.css，但进行了许多优化。 【:\u003e JFoenix-css是包含JFoenix包里每个控件的所有css样式的文件，是对JavaFx控件的扩展。】 步骤2：复制指定控件样式至新的css文件中 步骤3：修改JavaFX CSS 如果不熟悉 JavaFX 中使用的 CSS 变体，可以说看看JavaFX CSS 参考指南 。 它是一个非常强大的工具，可以设置/重新设置控件的样式。原则上，它与 web CSS 非常相似，除了它基于 CSS 2.1，所有属性都以“-fx-”为前缀，并且它有一些特殊的东西，比如对变量的内置支持等。 步骤4：覆盖项目中的控件样式 方法A: 样式表覆盖 样式表从 Scene 对象的 getStylesheets 属性中指定的 URL 加载，比如 scene.getStylesheets().add(ClassNameHere.class.getResource(\"/styles/restyled.css\").toExternalForm()); 方法B：内联样式覆盖 内联样式通过在fxml文件首行添加 Node setStyle API 指定，比如 stylesheets=\"@../../styles/restyled.css\" 注意\r样式选择器的优先顺序： 内联样式\u003e场景样式表\u003e用户代理样式表(默认) 样式选择器的优先顺序可以在样式声明中使用“！important”进行修改 ","date":"2022-06-06","objectID":"/customcontrols01/:0:3","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"实例 成果\r* Here are the things we need to do... * * 1.No gradients which leads to a more flat ui * 2.Different kind of checkmark * 3.Background filled when selected * 4.Different focus indicator /** 在组件CheckBox的css默认类check-box上做改动 **/ .check-box { -material-design-color : #3f51b5; -material-design-color-transparent-12: #3f51b51f; -material-design-color-transparent-24: #3f51b53e; -material-design-color-transparent-40: #3f51b566; -fx-font-family : \"Arial\"; /* Roboto Regular */ -fx-font-size : 13px; -fx-label-padding: 0em 0em 0em 1.1em; -fx-text-fill : -fx-text-background-color; } .check-box \u003e .box { -fx-background-color : transparent; -fx-background-insets : 0; -fx-border-color : #0000008a; -fx-border-width : 2px; -fx-border-radius : 2px; -fx-padding : 0.083333em; /* 1px */ -fx-text-fill : -fx-text-base-color; -fx-alignment : CENTER; -fx-content-display : LEFT; } .check-box:hover \u003e .box { -fx-background-color : #61616110, transparent; -fx-background-insets : -14, 0; -fx-background-radius : 1024; -fx-cursor : hand; } .check-box:focused \u003e .box { /* -fx-background-color : #6161613e, transparent;*/ -fx-background-insets : -14, 0; -fx-background-radius : 1024; } .check-box:pressed \u003e .box { -fx-background-color : -material-design-color-transparent-12, transparent; -fx-background-insets : -14, 0; -fx-background-radius : 1024; } .check-box:selected \u003e .box { -fx-background-color : -material-design-color; -fx-background-radius : 2px; -fx-background-insets : 0; -fx-border-color : transparent; } .check-box:selected:hover \u003e .box { -fx-background-color : -material-design-color-transparent-12, -material-design-color; -fx-background-insets : -14, 0; -fx-background-radius : 1024, 2px; -fx-border-color : transparent; -fx-cursor : hand; } .check-box:selected:focused \u003e .box { -fx-background-color : -material-design-color-transparent-24, -material-design-color; -fx-background-insets : -14, 0; -fx-background-radius : 1024, 2px; -fx-border-color : transparent; } .check-box:disabled { -fx-opacity: 0.46; } .check-box \u003e .box \u003e .mark { -fx-background-color: null; -fx-padding : 0.45em; -fx-scale-x : 1.1; -fx-scale-y : 0.8; -fx-shape : \"M-0.25,6.083c0.843-0.758,4.583,4.833,5.75,4.833S14.5-1.5,15.917-0.917c1.292,0.532-8.75,17.083-10.5,17.083C3,16.167-1.083,6.833-0.25,6.083z\"; } .check-box:indeterminate:hover \u003e .box { cursor:hand; } .check-box:indeterminate \u003e .box { -fx-background-color : -material-design-color-transparent-40; -fx-background-radius : 2px; -fx-background-insets : 0; -fx-border-color : transparent; } .check-box:indeterminate \u003e .box \u003e .mark { -fx-background-color: rgba(255, 255, 255, 0.87); -fx-shape : \"M0,0H10V2H0Z\"; -fx-scale-shape: false; -fx-padding : 0.666667em; } .check-box:selected \u003e .box \u003e .mark { -fx-background-color : rgba(255, 255, 255, 0.87); -fx-background-insets: 0; } /** 新建一个css类switch覆盖组件CheckBox的css默认类check-box **/ .switch { -material-design-color : #3f51b5; -material-design-color-transparent-12: #3f51b51f; -material-design-color-transparent-24: #3f51b53e; -material-design-color-transparent-40: #3f51b566; -fx-font-family : \"Arial\"; -fx-font-size : 13.0px; -fx-label-padding: 0em 0em 0em 1.1em; -fx-text-fill : -fx-text-background-color; } .switch \u003e *.box { -fx-background-color : #00000066; -fx-pref-height : 20; -fx-pref-width : 40; -fx-background-radius: 1024px; -fx-background-insets: 2.5; -fx-padding : 0; } .switch:selected \u003e *.box { -fx-background-color: -material-design-color-transparent-40; } .switch:disabled \u003e *.box { -fx-background-color: #0000001f; } .switch \u003e *.box \u003e *.mark { -fx-background-color : fafafa; -fx-padding : 0; -fx-background-insets: 0 10 0 10; -fx-background-radius: 1024px; -fx-translate-x : -8px; -fx-effect : dropshadow(gaussian, rgba(0, 0, 0, 0.3), 4.0, 0.5, 0.0, 1); } .switch:hover \u003e *.box \u003e *.mark { -fx-background-color : #61616110, white; -fx-background-insets: -14 -4 -14 -4, 0 10 0 10; -fx-background-radius: 1024px, 1024px; -fx-effect : dropshadow(gaussian, rgba(0, 0, 0, 0.3), 4.0, 0.2, 0.0, 1); } .switch:s","date":"2022-06-06","objectID":"/customcontrols01/:0:4","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"扩展 如何将自定义控件导入场景生成器？\r要将自定义控件导入 SceneBuilder，需要从控件创建一个 jar 并将此 jar 添加到 Library 文件夹。在 SceneBuilder中有一个可以单击的小齿轮图标。它的弹出菜单有一个名为“自定义库文件夹”的条目，其中有一个条目可以让您在资源管理器或查找器（取决于您的操作系统）中打开库文件夹。如果将创建的 jar 复制到此文件夹中，组件应出现在 Scene Builder 的“自定义”选项卡中。\r","date":"2022-06-06","objectID":"/customcontrols01/:0:5","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["JavaFx"],"content":"参考链接 Custom Controls in JavaFX (Part I) HanSolo/JavaFXCustomControls(github) JavaFX CSS 参考指南(API) ","date":"2022-06-06","objectID":"/customcontrols01/:0:6","tags":["controls","JavaFx","自定义控件"],"title":"JavaFx自定义控件（一）- 使用CSS重新设置现有控件的样式","uri":"/customcontrols01/"},{"categories":["Java基础"],"content":"\r技巧：带着问题去学习与理解Synchronized\rSynchronized可以作用在哪里?分别通过对象锁和类锁进行举例。 （✔） Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。 Synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的。 Synchronized和Lock的对比，和选择? Synchronized在使用时有何注意事项? Synchronized修饰的方法在抛出异常时,会释放锁吗? 多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程? Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法? 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办? 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁? 不同的JDK中对Synchronized有何优化? ","date":"2022-06-02","objectID":"/synchronized/:0:0","tags":["Synchronized关键字","Java多线程与并发"],"title":"关键字Synchronized的运用","uri":"/synchronized/"},{"categories":["Java基础"],"content":"一、Synchronized的使用场景 synchronized(重量级锁，对系统性能影响较大) 最常用于多线程并发编程时线程的同步。 synchronized可以修饰普通方法，静态方法和代码块。当synchronized修饰一个方法或者一个代码块的时候，它能够保证在同一时刻最多只有一个线程执行该段代码。 对于普通同步方法，锁是当前实例对象（不同实例对象之间的锁互不影响）。 对于静态同步方法，锁是当前类的Class对象。 对于同步代码块，锁是Synchonized括号里配置的对象。 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。 对象锁 应用于普通方法和代码块的同步 同步普通方法 public class UseSynchronized implements Runnable { static UseSynchronized instance = new UseSynchronized(); @Override public void run() { invokeMe(); } synchronized public void invokeMe(){ System.out.println(\"线程\" + Thread.currentThread().getName() + \"开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"结束\"); } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(instance); thread.start(); } } } 控制台输出：\routput\r注意\rsynchronized修饰普通方法时，默认的锁就是this对象锁，即当前实例对象锁\r同步代码块—this 即默认锁对象为当前实例对象 public class UseSynchronized implements Runnable { static UseSynchronized instance = new UseSynchronized(); @Override public void run() { //多个线程使用的锁是一样的,线程必须要等上一个线程释放锁后才能执行 synchronized (this) { System.out.println(\"线程\" + Thread.currentThread().getName() + \"开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"结束\"); } } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(instance); thread.start(); } } } 控制台输出：\routput\r注意\rthis指当前实例对象，所以synchronized (this)只能在多个线程作用于同一个实例对象时才能发挥作用。\r同步代码块—自定义锁 即自己手动创建锁：Object lock = new Object() /** * @author Azad-eng * Description:因为第二段代码块的锁与第一段代码块不一样，所以不会等到所有线程全部执行完第一段代码块后才执行第二段代码块 */ public class UseSynchronized implements Runnable { static UseSynchronized instance = new UseSynchronized(); //手动创建两把锁 Object lock1 = new Object(); Object lock2 = new Object(); @Override public void run() { synchronized (lock1) { System.out.println(\"线程\" + Thread.currentThread().getName() + \"拿到lock1锁后开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"释放lock1锁后结束\"); } synchronized (lock2) { System.out.println(\"线程\" + Thread.currentThread().getName() + \"拿到lock2锁后开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"释放lock2锁后结束\"); } } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(instance); thread.start(); } } } 控制台输出：\routput\r类锁 应用于静态方法的同步或指定锁对象为class对象 # 同步静态方法 public class UseSynchronized implements Runnable { @Override public void run() { invokeMe(); } static synchronized public void invokeMe(){ System.out.println(\"线程\" + Thread.currentThread().getName() + \"开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" +Thread.currentThread().getName() + \"结束\"); } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(new UseSynchronized()); thread.start(); } } } 控制台输出：\routput\r注意\r不同于普通方法只能作用于同一实例对象，修饰静态方法的synchronized可以保证不同实例对象的线程也能在执行方法时得到同步\r# 指定对象锁为class对象 public class UseSynchronized implements Runnable { @Override public void run() { //所有线程需要的锁都是同一把 synchronized (UseSynchronized.class) { System.out.println(\"线程\" + Thread.currentThread().getName() + \"开始\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"线程\" + Thread.currentThread().getName() + \"结束\"); } } public static void main(String[] args) { int threadNumbers = 4; for (int i = 0; i \u003c threadNumbers; i++) { Thread thread = new Thread(new UseSynchronized()); thread.start(); } } } 控制台输出：\routput\r","date":"2022-06-02","objectID":"/synchronized/:0:1","tags":["Synchronized关键字","Java多线程与并发"],"title":"关键字Synchronized的运用","uri":"/synchronized/"},{"categories":["Java基础"],"content":"二、Synchronized使用注意事项 使用Synchronized有哪些要注意的？ 锁对象不能为空，因为锁的信息都保存在对象头里 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错 避免死锁 在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错 synchronized是公平锁吗？ synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。 ","date":"2022-06-02","objectID":"/synchronized/:0:2","tags":["Synchronized关键字","Java多线程与并发"],"title":"关键字Synchronized的运用","uri":"/synchronized/"},{"categories":["Java基础"],"content":"参考链接： Java 全栈知识体系之关键字: synchronized详解 程序员自由之路之synchronized 的使用场景和原理简介 ","date":"2022-06-02","objectID":"/synchronized/:0:3","tags":["Synchronized关键字","Java多线程与并发"],"title":"关键字Synchronized的运用","uri":"/synchronized/"},{"categories":["Java基础"],"content":"Java创建对象并通过对象访问属性的可视化流程及对象拷贝","date":"2022-06-02","objectID":"/classvisulize/","tags":["java基础","Java Visualizer"],"title":"ClassVisulize","uri":"/classvisulize/"},{"categories":["Java基础"],"content":"\r","date":"2022-06-02","objectID":"/classvisulize/:0:0","tags":["java基础","Java Visualizer"],"title":"ClassVisulize","uri":"/classvisulize/"},{"categories":["Java基础"],"content":"Java创建对象并调用方法的可视化流程","date":"2022-06-02","objectID":"/methodvisualize/","tags":["java基础","Java Visualizer"],"title":"MethodVisualize","uri":"/methodvisualize/"},{"categories":["Java基础"],"content":"\r","date":"2022-06-02","objectID":"/methodvisualize/:0:0","tags":["java基础","Java Visualizer"],"title":"MethodVisualize","uri":"/methodvisualize/"},{"categories":["Java基础","网络通讯"],"content":"\rBIO和NIO的不同\rBIO以流的方式处理数据，而NIO以块的方式处理数据，后者效率高很多 BIO是阻塞的，而NIO是非阻塞的 BIO是基于字节流和字符流进行数据操作，且只能单向操作，即要么读取inputStream要么写出outputStream，而NIO基于Channel(通道)和Buffer(缓冲区)进行数据操作的，Buffer既可以读取get()也可以写入数据put()，只需通过flip进行读写切换即可,Channel也是双向的，可以返回底层OS的情况 BIO一个线程只能监听一个客户端，而BIO的Selector(选择器)可以用于监听多个通道的事件(比如：连接请求),因此使用单个线程就可以监听多个客户端通道 IoModel (nio\u0026bio)\r","date":"2022-06-01","objectID":"/iomodel/:0:0","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["Java基础","网络通讯"],"content":"演示BIO服务端线程池机制 package com.efl.bio; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Author: Azad-eng * Date: 2022/2/26 * Description: 演示线程池机制 */ public class BioServer { public static void main(String[] args) throws IOException { /** * 思路分析： * 1.创建一个线程池 * 2.如果有客户端连接，就创建一个线程与之通信(单独写一个方法) */ ExecutorService threadPool = Executors.newCachedThreadPool(); ServerSocket serverSocket = new ServerSocket(6666); while (true) { //监听，等待客户端连接,得到一个不可更改的Socket //如果没有连接会堵塞在这里 System.out.println(\"server has started, accepting...\"); Socket socket = serverSocket.accept(); System.out.println(\"连接到一个client了！\"); //执行线程池里new出来的线程，重写里面的run方法 threadPool.execute(new Runnable() { @Override public void run() { //这里就可以和客户端通信了，单独写一个通信的方法，把客户端连接上的socket传进去(没有这个socket无法进行通信) //调用该方法handler(socket)进行通信 //测试线程信息 System.out.println( \"启动了线程:id=\" + Thread.currentThread().getId() + \" name=\" + Thread.currentThread().getName() + \"\\n可以进行通信了！\"); handler(socket); } }); } } public static void handler(Socket socket) { try { //建立一个容量为1024的字节数组来接收数据 byte[] bytes = new byte[1024]; InputStream inputStream = socket.getInputStream(); //持续读取client发送的数据(该数据被装在了bytes字节数组中) while (true) { //read()方法返回的是接收的data的下一个byte(类型为int),如果返回-1代表inputStream到底了 //与NIO不同的是：如果服务端没有接收到客户端发出的数据线程会堵塞在这里 System.out.println(\"reading...\"); int read = inputStream.read(bytes); if (read != -1) { //把读取到的数据(字节数组——\u003e字符串)print出来 System.out.println(new String(bytes, 0, read)); } else { //程序执行到这里代表数据读取到底了，那么就退出while循环，接着关闭流，退出通信 break; } } } catch (IOException e) { e.printStackTrace(); } finally { try { System.out.println(\"线程:id=\" + Thread.currentThread().getId() + \" name=\" + Thread.currentThread().getName() +\"关闭了和server的连接\"); socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } ","date":"2022-06-01","objectID":"/iomodel/:0:1","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["Java基础","网络通讯"],"content":"演示NIO核心组件之一Buffer的使用 package com.efl.nio; import java.nio.IntBuffer; /** * Author: Azad-eng * Date: 2022/2/26 * Description:演示NIO核心组件之一Buffer的使用 */ public class BasicBuffer { public static void main(String[] args) { /** * 思路分析： * 1.创建一个IntBuffer,容量为5个int * 2.向里面存放数据10,11,12,13,14 * 3.从里面读取数据 */ IntBuffer intBuffer = IntBuffer.allocate(5); //存放数据,执行该方法一次，position在底层会自动+1 intBuffer.put(10); //循环存放数据(不能超过intBuffer的容量限制),前面已经存放了2个int了，所以后面intBuffer.capacity()-2 for (int i = 0; i \u003c intBuffer.capacity() - 2; i++) { intBuffer.put(i + 12); } //如何从intBuffer中读取数据？ //读写切换(这里需要：写——\u003e读) intBuffer.flip(); /** * 常用方法如下： */ //将index的位置position设置为数组的第2位，即从第2位开始读，结果输出为11,12,13,14 intBuffer.position(1); //设置能读取到的数组数据的最大限制(不能\u003e=3个数据,即只能输出2个)，结果输出为11,12 intBuffer.limit(3); //循环读取数据: while (intBuffer.hasRemaining()){ //get()里面维护的是一个index，每get一次,索引就往右移动一次 //一个int=2bytes // 10 11 12 13 14 // ^ ^ ^ ^ ^ // ———————————————————— //| 0 | 2 | 4 | 6 | 8 | // ———————————————————— // ^ // | System.out.println(intBuffer.get()); } //get(int index) 可以读取指定索引位置处的数据 System.out.println(intBuffer.get(2)); } } ","date":"2022-06-01","objectID":"/iomodel/:0:2","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["Java基础","网络通讯"],"content":"演示NIO用FileChannel对本地文件进行IO操作-1 package com.efl.nio; import java.io.*; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; /** * Author: Azad-eng * Date: 2022/2/26 * Description: * 演示用FileChannel对本地文件进行IO操作案例1 * 1.输出.txt到本地文件目录 * 2.读取.txt文件并打印到控制台屏幕 */ public class FileChannel01 { public static void main(String[] args) throws IOException { // new FileChannel01().writeToOut(); new FileChannel01().readFromIn(); } public void writeToOut() throws IOException { /** * 思路分析： * 1.创建.txt文件的内容和在本地文件目录中的文件路径 * 2.创建一个文件输出流FileOutputStream * 3.通过FileOutputStream得到FileChannel * 4.创建缓冲区Buffer并分配容量空间 * 5.将文件写入put到缓冲区 * 6.再将缓冲区数据写入write到fileChannel中 * 7.关闭输出流 */ String srcTxt = \"hello world~\"; String dstPath = \"F:\\\\linder\\\\IoTest\\\\hello01.txt\"; FileOutputStream fileOutputStream = new FileOutputStream(dstPath); FileChannel channel = fileOutputStream.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put(srcTxt.getBytes()); byteBuffer.flip(); //将缓冲区的数据写入到file通道中(byteBuffer write to fileChannel) channel.write(byteBuffer); fileOutputStream.close(); } public void readFromIn() throws IOException { /** * 思路分析 * 1.根据目标文件地址生成文件 * 2.创建一个文件输入流,将文件数据放进去 * 3.通过FileInputStream得到FileChannel * 4.创建缓冲区Buffer并指定容量空间大小为文件的大小 * 5.再将缓冲区数据读取read到fileChannel中 * 6.打印 * 7.关闭输入流 */ String dstPath = \"F:\\\\linder\\\\IoTest\\\\hello01.txt\"; File file = new File(dstPath); FileInputStream fileInputStream = new FileInputStream(file); FileChannel channel = fileInputStream.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); channel.read(byteBuffer); byte[] array = byteBuffer.array(); System.out.println(new String(array)); fileInputStream.close(); } } ","date":"2022-06-01","objectID":"/iomodel/:0:3","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["Java基础","网络通讯"],"content":"演示NIO用FileChannel对本地文件进行IO操作-2 package com.efl.nio; import java.io.*; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; /** * Author: Azad-eng * Date: 2022/2/26 * Description:通过一个Buffer进行读写操作来完成对指定文件的拷贝 */ public class FileChannel02 { public static void main(String[] args) throws IOException { /** * 思路分析 * 1.得到copyFrom文件的文件输入流 * 2.通过文件输入流得到FileChannel * 3.创建缓冲区 * 4.循环的一边读取copyFrom的channel中的数据一边将数据写入到copyTo的channel中 * 5.关闭文件输入输出流 */ File file = new File(\"F:\\\\linder\\\\IoTest\\\\hello01.txt\"); FileInputStream fileInputStream = new FileInputStream(\"F:\\\\linder\\\\IoTest\\\\hello01.txt\"); FileChannel channelIn = fileInputStream.getChannel(); FileOutputStream fileOutputStream = new FileOutputStream(\"F:\\\\linder\\\\IoTest\\\\hello02.txt\"); FileChannel channelOut = fileOutputStream.getChannel(); ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length()); while (true){ /** * 注意!!! * 这里要将缓冲区重置一下，否则当文件读取到最后时，position=limit=0，然后一直都是read=0，一直循环读取，始终无法读取完数据 * positon = 0; * limit = capacity; * mark = 1; */ byteBuffer.clear(); int read = channelIn.read(byteBuffer); System.out.println(read); //当read = -1 表示channelIn中的数据已经被读完了，所以要退出读写循环中 if (read==-1){ break; } //翻转byteBuffer的功能，开始将byteBuffer的数据写入到channelOut中 byteBuffer.flip(); channelOut.write(byteBuffer); } fileInputStream.close(); fileOutputStream.close(); } } ","date":"2022-06-01","objectID":"/iomodel/:0:4","tags":["IO流","客户端与服务端"],"title":"IoModel","uri":"/iomodel/"},{"categories":["工作总结"],"content":"在windows上安装SSH服务器 [windows自带SSH服务器：应用和功能-管理可选功能] ","date":"2022-06-01","objectID":"/ssh2/:0:1","tags":["SSH","实用工具"],"title":"如何使用 SSH 控制连接 Windows 服务器？","uri":"/ssh2/"},{"categories":["工作总结"],"content":"用管理员身份启动PowerShell自动化部署OpenSSH 服务器 确保OpenSSH 可用于安装： Get-WindowsCapability -Online | ? Name -like 'OpenSSH*' 安装： Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 初始化配置 开启 SSHD 服务： Start-Service sshd 设置服务的自启动： Set-Service -Name sshd -StartupType 'Automatic' 确认防火墙： Get-NetFirewallRule -Name *ssh* ","date":"2022-06-01","objectID":"/ssh2/:0:2","tags":["SSH","实用工具"],"title":"如何使用 SSH 控制连接 Windows 服务器？","uri":"/ssh2/"},{"categories":["工作总结"],"content":"使用nsis制作Java程序安装包的记录，nsis还可以直接把jar包生成exe可执行文件，目前使用launch4j来制作exe","date":"2022-06-01","objectID":"/nsis/","tags":["安装包脚本程序","实用工具"],"title":"NSIS安装脚本","uri":"/nsis/"},{"categories":["工作总结"],"content":"常用变量 参数脚本\r用户定义的解压路径： $INSTDIR 程序文件目录： $PROGRAMFILES 包含 NSIS 安装目录的一个标记。在编译时会检测到。常用于在你想调用一个在 NSIS 目录下的资源时，例如：图标、界面…： ${NSISDIR} 开始菜单目录： $STARTMENU 开始菜单程序目录： $SMPROGRAMS ","date":"2022-06-01","objectID":"/nsis/:0:1","tags":["安装包脚本程序","实用工具"],"title":"NSIS安装脚本","uri":"/nsis/"},{"categories":["工作总结"],"content":"安装脚本 ; 该脚本使用 HM VNISEdit 脚本编辑器向导产生 ; 安装程序初始定义常量 !define INSTDIR \"E:\\nsis\\nsis_test\" !define PRODUCT_NAME \"EFL_PotatoOSp-8601Series\" !define PRODUCT_VERSION \"1.2.7-alpha\" !define PRODUCT_PUBLISHER \"Engineering For Life\" !define PRODUCT_WEB_SITE \"http://www.efl-tech.com/\" !define PRODUCT_DIR_REGKEY \"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\${PRODUCT_NAME}.exe\" !define PRODUCT_UNINST_KEY \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT_NAME}\" !define PRODUCT_UNINST_ROOT_KEY \"HKLM\" SetCompressor lzma ; ------ MUI 现代界面定义 (1.67 版本以上兼容) ------ !include \"MUI.nsh\" ; MUI 预定义常量 !define MUI_ABORTWARNING !define MUI_ICON \"E:\\test\\exe\\icons\\8601P.ico\" !define MUI_UNICON \"${NSISDIR}\\Contrib\\Graphics\\Icons\\modern-uninstall.ico\" ; 欢迎页面 !insertmacro MUI_PAGE_WELCOME ; 安装目录选择页面 !insertmacro MUI_PAGE_DIRECTORY ; 安装过程页面 !insertmacro MUI_PAGE_INSTFILES ; 安装完成页面 !define MUI_FINISHPAGE_RUN \"$INSTDIR\\${PRODUCT_NAME}.exe\" !insertmacro MUI_PAGE_FINISH !define MUI_FINISHPAGE_RUN_PARAMETERS \"-Dprism.order=sw\" ; 安装卸载过程页面 !insertmacro MUI_UNPAGE_INSTFILES ; 安装界面包含的语言设置 !insertmacro MUI_LANGUAGE \"SimpChinese\" ; 安装预释放文件 !insertmacro MUI_RESERVEFILE_INSTALLOPTIONS ; ------ MUI 现代界面定义结束 ------ ;引入nsh脚本-判断系统 !include \"x64.nsh\" Name \"${PRODUCT_NAME} ${PRODUCT_VERSION}\" OutFile \"${PRODUCT_NAME}_setup.exe\" InstallDirRegKey HKLM \"${PRODUCT_UNINST_KEY}\" \"UninstallString\" ShowInstDetails show ShowUnInstDetails show BrandingText \"EFL, Inc. \" Section \"Test\" Test SetOutPath \"$INSTDIR\" SectionEnd Function .onInit #安装目录设置 ${If} ${RunningX64} StrCpy $INSTDIR \"$PROGRAMFILES64\\${PRODUCT_NAME}\" ${else} StrCpy $INSTDIR \"$PROGRAMFILES\\${PRODUCT_NAME}\" ${EndIf} FunctionEnd Section \"MainSection\" SEC01 SetOverwrite ifdiff RMDir /r \"$INSTDIR\\预置模型\" RMDir /r \"$INSTDIR\\update\" RMDir /r \"$INSTDIR\\bin\\Slic3r\" RMDIR /r \"$SMPROGRAMS\\${PRODUCT_NAME}\" SetOutPath \"$INSTDIR\\bin\" File /r \"E:\\test\\exe\\bin\\*.*\" SetOutPath \"$INSTDIR\\image\" File /r \"E:\\test\\exe\\image\\*.*\" SetOutPath \"$INSTDIR\\jre\" File /r \"E:\\test\\exe\\jre\\*.*\" SetOutPath \"$INSTDIR\\libs\" File /r \"E:\\test\\exe\\libs\\*.*\" SetOutPath \"$INSTDIR\\stl\" File /r \"E:\\test\\exe\\stl\\*.*\" SetOutPath \"$INSTDIR\\update\" File /r \"E:\\test\\exe\\update\\*.*\" SetOutPath \"$INSTDIR\\预置模型\" File /r \"E:\\test\\exe\\预置模型\\*.*\" SetOutPath \"$INSTDIR\" File \"E:\\test\\exe\\${PRODUCT_NAME}.exe\" ; 创建开始菜单快捷方式 CreateDirectory \"$SMPROGRAMS\\${PRODUCT_NAME}\" CreateShortCut \"$SMPROGRAMS\\${PRODUCT_NAME}\\${PRODUCT_NAME}.lnk\" \"$INSTDIR\\${PRODUCT_NAME}.exe\" ; 创建桌面菜单快捷方式 CreateShortCut \"$DESKTOP\\${PRODUCT_NAME}.lnk\" \"$INSTDIR\\${PRODUCT_NAME}.exe\" SectionEnd Section -AdditionalIcons WriteIniStr \"$INSTDIR\\EFL官网.url\" \"InternetShortcut\" \"URL\" \"${PRODUCT_WEB_SITE}\" WriteIniStr \"$SMPROGRAMS\\${PRODUCT_NAME}\\EFL官网.url\" \"InternetShortcut\" \"URL\" \"${PRODUCT_WEB_SITE}\" SectionEnd Section -Post WriteUninstaller \"$INSTDIR\\uninst.exe\" WriteRegStr HKLM \"${PRODUCT_DIR_REGKEY}\" \"\" \"$INSTDIR\\${PRODUCT_NAME}.exe\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"DisplayName\" \"$(^Name)\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"UninstallString\" \"$INSTDIR\\uninst.exe\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"DisplayIcon\" \"$INSTDIR${PRODUCT_NAME}.exe\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"DisplayVersion\" \"${PRODUCT_VERSION}\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"URLInfoAbout\" \"${PRODUCT_WEB_SITE}\" WriteRegStr ${PRODUCT_UNINST_ROOT_KEY} \"${PRODUCT_UNINST_KEY}\" \"Publisher\" \"${PRODUCT_PUBLISHER}\" SectionEnd /****************************** * 以下是安装程序的卸载部分 * ******************************/ Section Uninstall Delete \"$INSTDIR\\EFL官网.url\" Delete \"$INSTDIR\\uninst.exe\" Delete \"$INSTDIR\\${PRODUCT_NAME}.exe\" Delete \"$SMPROGRAMS\\${PRODUCT_NAME}\\${PRODUCT_NAME}.lnk\" Delete \"$SMPROGRAMS\\${PRODUCT_NAME}\\EFL官网.url\" Delete \"$DESKTOP\\${PRODUCT_NAME}.lnk\" RMDir /r \"$INSTDIR\\预置模型\" RMDir /r \"$INSTDIR\\update\" RMDir /r \"$INSTDIR\\stl\" RMDir /r \"$INSTDIR\\jre\" RMDir /r \"$INSTDIR\\libs\" RMDir /r \"$INSTDIR\\ima","date":"2022-06-01","objectID":"/nsis/:0:2","tags":["安装包脚本程序","实用工具"],"title":"NSIS安装脚本","uri":"/nsis/"},{"categories":["工作总结"],"content":"参考链接： NSIS官网文章参考 ","date":"2022-06-01","objectID":"/nsis/:0:3","tags":["安装包脚本程序","实用工具"],"title":"NSIS安装脚本","uri":"/nsis/"},{"categories":["工作总结"],"content":"通过配置maven的pom文件来自定义打包jar","date":"2022-06-01","objectID":"/maven-pom/","tags":["maven"],"title":"Maven-Pom","uri":"/maven-pom/"},{"categories":["工作总结"],"content":"方法一：使用 maven-jar-plugin 和 maven-dependency-plugin \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.***\u003c/groupId\u003e \u003cartifactId\u003e***\u003c/artifactId\u003e \u003cversion\u003e1.2.n\u003c/version\u003e \u003cdescription\u003e*** Printer\u003c/description\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.2.0.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c/parent\u003e \u003cproperties\u003e \u003cjava.version\u003e8\u003c/java.version\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 其他的一些dependency... --\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003c!--该插件的作用是配置mainClass，classpath--\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-jar-plugin\u003c/artifactId\u003e \u003cversion\u003e3.1.2\u003c/version\u003e \u003cconfiguration\u003e \u003carchive\u003e \u003cmanifest\u003e \u003c!--是否在manifest文件中添加classpath。默认为false。如果为true，则会在manifest文件中添加classpath--\u003e \u003caddClasspath\u003etrue\u003c/addClasspath\u003e \u003c!--classpath的前缀，比如libs/xx.jar，所有外部依赖jar包所在的文件夹名libs+jar包共同组成了类路径Class-Path--\u003e \u003cclasspathPrefix\u003elibs/\u003c/classpathPrefix\u003e \u003c!--这里改成你主类的全限定名称,mainClass = 启动时的Main Class--\u003e \u003cmainClass\u003e com.efl.javafx.desktop.ClientApplication \u003c/mainClass\u003e \u003c/manifest\u003e \u003c/archive\u003e \u003cclassifier\u003ebak\u003c/classifier\u003e \u003c/configuration\u003e \u003c!--在执行package动作的时候，自动打包--\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003ejar\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c!-- 该插件的作用是把所依赖的jar包copy到指定目录outputDirectory --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-dependency-plugin\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003ecopy-dependencies\u003c/id\u003e \u003cphase\u003eprepare-package\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ecopy-dependencies\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003c!--outputDirectory中的类路径要与maven-jar-plugin中的classpath一致--\u003e \u003coutputDirectory\u003e E:/packet/***/1-2-8/libs \u003c/outputDirectory\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c!-- 其他的一些plugin... --\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e 打包结果\r├── PotatoOSp-Client-1.2.n-bak.jar ├── libs ├── spring-boot-starter.jar\r├── 其它jar\r优点\r有诸多配置项，很自由，每个步骤都可控，然后生成的jar包是轻量级的，大小就是我们自己程序的大小\r缺点\r最终jar包中没有所依赖的jar包。依赖跟自己的代码不在一个jar包中。部署或者移动的时候，要考虑到多个文件，比较麻烦\r","date":"2022-06-01","objectID":"/maven-pom/:0:1","tags":["maven"],"title":"Maven-Pom","uri":"/maven-pom/"},{"categories":["工作总结"],"content":"方法二：使用spring-boot-maven-plugin \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003c!-- 工程主入口--\u003e \u003cclassifier\u003espring-boot\u003c/classifier\u003e \u003cmainClass\u003e com.***.javafx.desktop.ClientApplication \u003c/mainClass\u003e \u003cincludeSystemScope\u003etrue\u003c/includeSystemScope\u003e \u003caddResources\u003efalse\u003c/addResources\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003erepackage\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 优点\r能同时打可执行jar包和war包，所有依赖都在可执行jar包中，可以方便的在任何位置都能直接运行\r缺点\r添加了一些不必要的Spring和Spring Boot依赖\r","date":"2022-06-01","objectID":"/maven-pom/:0:2","tags":["maven"],"title":"Maven-Pom","uri":"/maven-pom/"},{"categories":["工作总结"],"content":"参考链接： Maven - 打包可执行jar包 ","date":"2022-06-01","objectID":"/maven-pom/:0:3","tags":["maven"],"title":"Maven-Pom","uri":"/maven-pom/"},{"categories":["LeetCode"],"content":"判断字符串是否为回文串(正读反读一样的字符串，比如level,noon)","date":"2022-06-01","objectID":"/ispalindrome/","tags":["String"," LeetCode-Easy"],"title":"IsPalindrome","uri":"/ispalindrome/"},{"categories":["LeetCode"],"content":" package efl.ryl.easy; /** * Author: Azad-eng * Date: 2022/3/5 * Description: * 判断字符串是否是回文串(正读反读一样的字符串，比如level,noon) */ public class IsPalindrome { public boolean method1(String srcString) { /** * 思路分析： * 方法1——筛选+判断 * 1)遍历字符串srcString进行筛选(Character.isLetterOrDigit(srcString.charAt()))，只保留字母字符和数字字符 * 2)将筛选后的字符串的每一个字符都转换成小写(Character.toLowerCase())并放进另一个新的字符串中desString(new-\u003eappend), * 3)判断desString是否为回文串： * -使用翻转字符串的方法reverse得到把desString倒序读的字符串revString(注意这里要生成一个新的倒置的字符串，不能直接改变desString) * -将revString与desString进行相等判断,如果相等返回true，表示是回文串，反之false */ StringBuffer desString = new StringBuffer(); for (int i = 0; i \u003c srcString.length(); i++) { if (Character.isLetterOrDigit(srcString.charAt(i))) { desString.append(Character.toLowerCase(srcString.charAt(i))); } } // StringBuffer reverse = desString.reverse(); x // desString是StringBuffer类的,保存的是字符串变量,不同于String,里面的值是可以更改的。为了避免这种更改,所以要新建一个StringBuffer StringBuffer revString = new StringBuffer(desString).reverse(); // return revString.equals(desString); x // 这里的revString和desString是两个object，这里equals判断的是两个对象是否是同一个对象，而不是判断它们的值是否相等 return (new String(revString)).equals(new String(desString)); } public boolean method2(String srcString) { /** * 思路分析 * 方法2——双指针 * 1)引入两个index变量int left=0 , int right = srcString.length()-1 * 2)+————————————————————+ * | | | | | | | | * +————————————————————+ * ^ ^ * | | * left right * 3)让left向右移动，right向左移动，一直循环到left\u003eright,如果期间遇到非数字或字母的字符就让left++,或right--，即跳过它们 * 4)对全部转成成小写的字符做出相等判断，一旦有一组字符不等，就返回false，如果循环结束依然没有返回false，代表该字符串是回文串，那么返回true */ int left = 0; int right = srcString.length() - 1; while (left \u003c= right){ if(Character.toLowerCase(srcString.charAt(left))!=Character.toLowerCase(srcString.charAt(right))){ return false; } left++; right--; if (!Character.isLetterOrDigit(srcString.charAt(left))){ left++; } if (!Character.isLetterOrDigit(srcString.charAt(right))){ right--; } } return true; } public static void main(String[] args) { System.out.println(new IsPalindrome().method2(\"l,ev e l\")); } } ","date":"2022-06-01","objectID":"/ispalindrome/:0:0","tags":["String"," LeetCode-Easy"],"title":"IsPalindrome","uri":"/ispalindrome/"},{"categories":["LeetCode"],"content":"二维列表的运用——杨辉三角","date":"2022-06-01","objectID":"/pascaltriangle/","tags":["二维列表"," LeetCode-Easy","ArrayList"],"title":"PascalTriangle","uri":"/pascaltriangle/"},{"categories":["LeetCode"],"content":" package efl.ryl.easy; import java.util.ArrayList; import java.util.List; /** * Author: Azad-eng * Date: 2022/3/3 * Description: 杨辉三角 */ public class Pascal_Triangle { // [1] // [1,1] // [1,2,1] // [1,3,3,1] // [1,4,6,4,1] // [............] public List\u003cList\u003cInteger\u003e\u003e generate(int numRows) { //二维列表的运用——杨辉三角 /** * 思路分析： * 1.主集合List\u003cList\u003cInteger\u003e\u003e ret有且仅有一个，但子集合List\u003cInteger\u003e row 有numRows个(numRows=ret.size()),因此要new创建ret.size()个row * -所以 for (int i = 0; i \u003c numRows; ++i) {} * 2.row集合中元素的add规律：第1行，add 1次，第2行，add 2次...第numRows行，add numRows次 * -所以 for (int j = 0; j \u003c= i; ++j){} * 3.add的值也有规律： * -3.1 每一行头尾(第一个行头尾重合)的值都是1：row.get(0)=1，row.get(i)=1 * -所以if (j == 0 || j == i) {row.add(1);} * -3.2 非头尾的值 =上一行的相同位置的前一个元素的值 +上一行的相同位置的元素的值 * -所以 row.add(ret.get(i-1).get(j-1) + ret.get(i-1).get(j)) */ //List是接口，不能实例化,因此List\u003cList\u003cInteger\u003e\u003e list = new List\u003c\u003e(); x List\u003cList\u003cInteger\u003e\u003e ret = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c= numRows - 1; i++) { List\u003cInteger\u003e row = new ArrayList\u003c\u003e(); for (int j = 0; j \u003c= i; j++) { if (j == 0 || j == i) { row.add(1); } else { row.add(ret.get(i - 1).get(j - 1) + ret.get(i - 1).get(j)); } } ret.add(row); } return ret; } public static void main(String[] args) { System.out.println(new Pascal_Triangle().generate(5)); } } ","date":"2022-06-01","objectID":"/pascaltriangle/:0:0","tags":["二维列表"," LeetCode-Easy","ArrayList"],"title":"PascalTriangle","uri":"/pascaltriangle/"},{"categories":["LeetCode"],"content":"返回和为目标值的两数的下标数组","date":"2022-06-01","objectID":"/twosums/","tags":["哈希查找"," LeetCode-Easy","数组","int[]"],"title":"TwoSums","uri":"/twosums/"},{"categories":["LeetCode"],"content":" package efl.ryl.easy; import java.util.*; /** * Author: Azad-eng * Date: 2022/3/5 * Description: 返回和为目标值的两数的下标数组 */ public class TwoSums { public int[] method1(int[] nums, int target) { /** * 暴力解法——线性查找(完整的遍历一次数组的时间复杂度为——O[n]) * 当i=0时，j={1,2...nums.length-1}即需要将i与j比较n-1次 * 当i=1时，j={2,3...nums.length-1}即需要将i与j比较n-2次 * ...... * 当i=n-1时，j={nums.length-1}即需要将i与j比较1次 * 一共比较了(n-1)+(n-2)+(n-3)+...1次 * 等差序列求和：n*(n-1)/2 = 1/2 n^2 - 1/2n * 因此时间复杂度=O(n^2) */ int[] ints = new int[2]; for (int i = 0; i \u003c nums.length; i++) { for (int j = 0; j \u003c nums.length; j++) { if (i != j \u0026\u0026 (nums[j] == target - nums[i])) { ints[0] = j; ints[1] = i; break; } } } return ints; } public int[] method2(int[] nums, int target) { /** * 优化——哈希查找 * 时间复杂度=O(n) * [优势只有在数据量大时才能凸显] */ if (nums == null || nums.length == 0) { return new int[0]; } HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); Set\u003cInteger\u003e keySet = map.keySet(); for (int i = 0; i \u003c nums.length; i++) { map.put(i, nums[i]); if (map.containsValue(target - nums[i])) { for (Integer key : keySet) { if (map.get(key).equals(target - nums[i]) \u0026\u0026 key != i) { return new int[]{key, i}; } } } } return new int[0]; } public static void main(String[] args) { System.out.println(Arrays.toString(new TwoSums().method2(new int[]{3, 2, 4}, 6))); } } ","date":"2022-06-01","objectID":"/twosums/:0:0","tags":["哈希查找"," LeetCode-Easy","数组","int[]"],"title":"TwoSums","uri":"/twosums/"},{"categories":["Java基础"],"content":"流程控制图｛顺序｝｛分支｝｛循环｝｛break｝{continue}","date":"2022-05-31","objectID":"/controlflow/","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":["Java基础"],"content":"顺序控制 程序从上到下逐行执行，中间没有任何判断和跳转 ","date":"2022-05-31","objectID":"/controlflow/:0:1","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":["Java基础"],"content":"分支控制 让程序有选择的执行 分支控制 (if)\r分支控制 (switch)\r","date":"2022-05-31","objectID":"/controlflow/:0:2","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":["Java基础"],"content":"循环控制 满足条件则程序循环执行，通过变量迭代，等到条件无法满足时就退出循环。因此引入合适的迭代的变量可以有效的规避死循环 循环控制\r","date":"2022-05-31","objectID":"/controlflow/:0:3","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":["Java基础"],"content":"循环跳转控制 break[用于终止某个语句块的执行，一般用于switch分支控制或者循环控制程序中] 循跳转环控制 (break)\rcontinue[用于结束本次循环，继续执行下一次循环] 注意\r注意不同于break，continue语句执行前一定要有迭代变量操作，否则就会陷入死循环 for循环比较特殊，虽然for循环内的迭代变量的执行顺序的确在循环体操作之后，但是它不在循环体内，所以continue没有跳过它，执行完continue语句后，会接着执行迭代变量操作，再执行条件判断 循跳转环控制 (continue)\rreturn[表示让程序跳出当前所在的方法，然后继续执行] ","date":"2022-05-31","objectID":"/controlflow/:0:4","tags":["java基础","程序流程图"],"title":"ControlFlow","uri":"/controlflow/"},{"categories":null,"content":"\r","date":"2022-05-25","objectID":"/friends/:0:0","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"★^/^★~ 阮一峰的网络日志\r\"这里记录每周值得分享的科技内容，周五发布。\"\r大大的小蜗牛\r\"机会总是垂青于有准备的人\"\rElizen\r\"There is only one thing in the world worse than being talked about, and that is not being talked about.\"\r雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r巴托什切哈诺夫斯基\r\"知识型博客\"\r发现内在的自然\r\"人生中不存在任何必须的事情，不管什么事，只要允许它存在，它就不是一个问题\"\r","date":"2022-05-25","objectID":"/friends/:0:1","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"coding~ Java 全栈知识体系\r\"包含: Java 基础, Java 部分源码, JVM, Spring, Spring Boot, Spring Cloud, 数据库原理, MySQL, ElasticSearch, MongoDB, Docker, k8s, CI\u0026CD, Linux, DevOps, 分布式, 中间件, 开发工具, Git, IDE, 源码阅读，读书笔记, 开源项目...\"\r代码随想录\r\"本站是一套完整的刷题计划，旨在帮助大家少走弯路，循序渐进学算法\"\rJava 程序员进阶之路\r\"沉默王二的专属知识星球\"\r程序员自由之路\r\"\"\r张小凯的博客\r\"\"\rmanateelazycat\r\"生活可以更简单, 欢迎来到我的开源世界\"\r风祈的时光录\r\"主要是Java技术栈的文章，涉及到了源码、原理的知识\"\r_跑调大叔_\r\"天下事有难易乎 \u003e 为之，则难者亦易 \u003e 不为，则易者亦难\"\rCqh-i\r\"你的问题,主要在于读书不多而想得太多\"\rBarney’s Blog\r\"All the truth is simple\"\r低调小熊猫\r\"读万卷书，行万里路，赚很多钱\"\r","date":"2022-05-25","objectID":"/friends/:0:2","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"others~ 概念清楚吧\r\"写点平时科研的时候会关注的问题\"\r","date":"2022-05-25","objectID":"/friends/:0:3","tags":null,"title":"Azadの友人帐","uri":"/friends/"},{"categories":null,"content":"\r","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"\r","date":"0001-01-01","objectID":"/treasure/:0:0","tags":null,"title":"🧰宝藏收藏匣","uri":"/treasure/"},{"categories":null,"content":"学习圣地~📝📚📖🏛 CS 61A \"计算机程序构造和解释网络课程（python）\"\rSICP Interactive Book \"计算机程序构造和解释在线阅读（交互式）\"\r","date":"0001-01-01","objectID":"/treasure/:0:1","tags":null,"title":"🧰宝藏收藏匣","uri":"/treasure/"},{"categories":null,"content":"实用的工具~🔨✒📐 Fontawesome Icon\r\"为项目找到最适合的图标\"\rSVG Editor\r\"SvgPath编辑器\"\rRegexr\r\"学习、构建和测试正则表达式\"\riloveimg\r\"在线压缩PNG图像工具\"\r","date":"0001-01-01","objectID":"/treasure/:0:2","tags":null,"title":"🧰宝藏收藏匣","uri":"/treasure/"},{"categories":null,"content":"API文档速查~🔎 Java\r\"Java™ Platform, Standard Edition 8 API\"\rJavaFx\r\"JavaFX 8 API\"\rJSSC\r\"JSSC API\"\r","date":"0001-01-01","objectID":"/treasure/:0:3","tags":null,"title":"🧰宝藏收藏匣","uri":"/treasure/"}]